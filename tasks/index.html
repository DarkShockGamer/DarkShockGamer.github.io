<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/png" href="/assets/logo.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="/assets/css/adaptive-themes.css">
  <link rel="stylesheet" href="/assets/css/task-tags.css">
  <!-- Privacy-friendly analytics by Plausible -->
  <script async src="https://plausible.io/js/pa-M5H8HPpMEkcSIPK4fxOhN.js"></script>
  <script>
    window.plausible=window.plausible||function(){(plausible.q=plausible.q||[]).push(arguments)},plausible.init=plausible.init||function(i){plausible.o=i||{}};
    plausible.init()
  </script>
  <!-- Pre-paint theme application to prevent FOUC -->
  <script>
    (function() {
      // Migration map for old adaptive themes
      const migrationMap = {
        'sunrise': 'light',
        'daylight': 'light',
        'sunset': 'dark',
        'midnight': 'dark'
      };
      
      // Valid new adaptive themes
      const validAdaptiveThemes = ['light', 'dark', 'high-contrast-light', 'high-contrast-dark'];
      
      // Check for adaptive theme first
      let adaptiveTheme = localStorage.getItem('site-adaptive-theme');
      
      // Migrate old theme if found
      if (adaptiveTheme && migrationMap[adaptiveTheme]) {
        adaptiveTheme = migrationMap[adaptiveTheme];
        localStorage.setItem('site-adaptive-theme', adaptiveTheme);
      }
      
      // Remove all existing theme classes to prevent conflicts
      const html = document.documentElement;
      html.classList.remove('theme-light', 'theme-dark', 'theme-high-contrast',
                            'theme-high-contrast-light', 'theme-high-contrast-dark',
                            'theme-sunrise', 'theme-daylight', 'theme-sunset', 'theme-midnight');
      
      if (adaptiveTheme && validAdaptiveThemes.includes(adaptiveTheme)) {
        html.classList.add('theme-' + adaptiveTheme);
      } else {
        // If no valid adaptive theme, default to light
        adaptiveTheme = 'light';
        localStorage.setItem('site-adaptive-theme', adaptiveTheme);
        html.classList.add('theme-light');
      }
    })();
  </script>
  <title>Trident Robotics — Task Board</title>
  <!-- JWT decode library for authentication -->
  <script src="https://cdn.jsdelivr.net/npm/jwt-decode@3/build/jwt-decode.min.js"></script>
  <!-- Shared auth configuration and guard -->
  <script src="/assets/js/auth-config.js"></script>
  <script src="/assets/js/auth-guard.js"></script>
  
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { background: linear-gradient(to bottom, #f0f9ff, white); font-family: system-ui, sans-serif; }
    .dragging { opacity: 0.5; transform: scale(1.02); }
    .droppable-hover { outline: 2px dashed rgba(2,132,199,0.35); outline-offset: 4px; background-color: rgba(2,132,199,0.06) !important; }

    /* Drawer styles */
    .drawer { position: fixed; top: 0; right: -100%; width: 100%; max-width: 480px; height: 100vh; background: white; box-shadow: -4px 0 24px rgba(0,0,0,0.15); transition: right 0.3s ease-in-out; z-index: 1001; overflow-y: auto; }
    .drawer.open { right: 0; }
    .drawer-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: none; }
    .drawer-overlay.active { display: block; }

    /* Due date colors */
    .due-overdue { color: #dc2626 !important; } /* red-600 */
    .due-soon { color: #d97706 !important; }    /* amber-600 */

    /* Dropdown layout */
    .dropdown { position: relative; width: 12rem; }
    .dropdown-btn {
      width: 100%; border: 1px solid #d1d5db; border-radius: 0.5rem; padding: 0.5rem; background: white; cursor: pointer; text-align: left;
      display: flex; align-items: center; gap: 0.25rem; flex-wrap: wrap; min-height: 2.25rem;
    }
    .dropdown-btn:hover { border-color: #93c5fd; }
    .dropdown-list {
      position: absolute; top: 100%; left: 0; right: 0; border: 1px solid #d1d5db; border-radius: 0.5rem; background: white;
      max-height: 220px; overflow-y: auto; display: none; z-index: 1000; box-shadow: 0 8px 24px rgba(2, 132, 199, 0.15); margin-top: 0.25rem;
    }
    .dropdown-list label {
      display: flex; align-items: center; gap: 0.5rem; padding: 0.5rem 0.625rem; cursor: pointer; width: 100%; user-select: none; line-height: 1.1;
    }
    .dropdown-list label:hover { background-color: #e0f2fe; }
    .dropdown-list input[type="checkbox"] { margin: 0; }
    .dropdown-list input[type="radio"] { margin: 0; }

    /* Tag chips */
    .tag-chip {
      display: inline-block; background: #e0f2fe; color: #0369a1; padding: 0.125rem 0.5rem; border-radius: 9999px; margin-right: 0.25rem; margin-bottom: 0.25rem;
      font-size: 0.75rem; line-height: 1.25rem; white-space: nowrap; border: 1px solid #bae6fd;
    }
    /* Per-team tag colors */
    .tag-chip[data-tag="mechanical"] { background: #fee2e2; color: #991b1b; border-color: #fecaca; }
    .tag-chip[data-tag="design"] { background: #dbeafe; color: #1e40af; border-color: #bfdbfe; }
    .tag-chip[data-tag="electrical"] { background: #fef3c7; color: #92400e; border-color: #fde68a; }
    .tag-chip[data-tag="programming"] { background: #f3e8ff; color: #6b21a8; border-color: #e9d5ff; }
    .tag-chip[data-tag="website"] { background: #cffafe; color: #155e75; border-color: #a5f3fc; }
    .tag-chip[data-tag="business"] { background: #f1f5f9; color: #475569; border-color: #cbd5e1; }
    .tag-chip[data-tag="drive"] { background: #fed7aa; color: #9a3412; border-color: #fdba74; }
    .dropdown-btn .placeholder { color: #94a3b8; }

    /* Board grid layout */
    #board { align-items: stretch; }

    /* Column styling */
    .column-section { background: white; border: 1px solid #e2e8f0; border-radius: 1rem; box-shadow: 0 1px 2px rgba(2, 6, 23, 0.05); padding: 1rem; display: flex; flex-direction: column; }
    .column-header {
      display: flex; align-items: center; justify-content: space-between; margin-bottom: 0.75rem; background: rgba(241,245,249,0.6);
      border: 1px solid #e2e8f0; border-radius: 0.75rem; padding: 0.5rem 0.75rem;
    }
    .column-count { color: #0369a1; background: #e0f2fe; border: 1px solid #bae6fd; border-radius: 9999px; padding: 0 0.5rem; font-size: 0.75rem; line-height: 1.25rem; }
    .task-list { flex: 1; }

    /* Task card */
    .task-card { position: relative; background: white; border: 1px solid #e2e8f0; border-radius: 0.75rem; padding: 0.75rem; padding-bottom: 2.5rem; box-shadow: 0 1px 1px rgba(2, 6, 23, 0.04); transition: box-shadow 150ms, border-color 150ms; }
    .task-card:hover { box-shadow: 0 6px 16px rgba(2,132,199,0.12); border-color: #93c5fd; transform: translateY(-1px); }

    /* Custom checkbox styling for description checklist */
    .desc-checkbox {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none;
      width: 1rem;
      height: 1rem;
      border: 2px solid #d1d5db;
      border-radius: 0.25rem;
      background-color: white;
      cursor: pointer;
      position: relative;
      flex-shrink: 0;
      transition: all 150ms;
    }
    .desc-checkbox:hover {
      border-color: #10b981;
    }
    .desc-checkbox:checked {
      background-color: #10b981;
      border-color: #10b981;
    }
    .desc-checkbox:checked::after {
      content: '';
      position: absolute;
      left: 0.25rem;
      top: 0.0625rem;
      width: 0.375rem;
      height: 0.625rem;
      border: solid white;
      border-width: 0 2px 2px 0;
      transform: rotate(45deg);
    }

    /* Dark mode */
    @media (prefers-color-scheme: dark) {
      html, body { color-scheme: dark; }
      body { background: linear-gradient(to bottom, #0b1220, #0a0f1a); color: #e5e7eb; }

      .dropdown-btn { background: #0b1220 !important; border-color: #334155 !important; color: #e5e7eb !important; }
      .dropdown-btn:hover { border-color: #0ea5e9 !important; }
      .dropdown-list { background: #0b1220 !important; border-color: #334155 !important; box-shadow: 0 8px 24px rgba(14, 165, 233, 0.12); }
      .dropdown-list label:hover { background-color: rgba(14,165,233,0.1) !important; }
      .dropdown-list input[type="checkbox"] { accent-color: #0ea5e9; }
      .dropdown-list input[type="radio"] { accent-color: #0ea5e9; }
      .dropdown-btn .placeholder { color: #94a3b8 !important; }

      .tag-chip { background: #0c4a6e !important; color: #e0f2fe !important; border-color: #075985 !important; }
      /* Dark mode per-team tag colors */
      .tag-chip[data-tag="mechanical"] { background: #7f1d1d !important; color: #fecaca !important; border-color: #991b1b !important; }
      .tag-chip[data-tag="design"] { background: #1e3a8a !important; color: #bfdbfe !important; border-color: #1e40af !important; }
      .tag-chip[data-tag="electrical"] { background: #78350f !important; color: #fde68a !important; border-color: #92400e !important; }
      .tag-chip[data-tag="programming"] { background: #581c87 !important; color: #e9d5ff !important; border-color: #6b21a8 !important; }
      .tag-chip[data-tag="website"] { background: #0e7490 !important; color: #a5f3fc !important; border-color: #155e75 !important; }
      .tag-chip[data-tag="business"] { background: #334155 !important; color: #cbd5e1 !important; border-color: #475569 !important; }
      .tag-chip[data-tag="drive"] { background: #7c2d12 !important; color: #fdba74 !important; border-color: #9a3412 !important; }
      .column-section { background: #0f172a !important; border-color: #1f2937 !important; box-shadow: 0 1px 2px rgba(2, 6, 23, 0.3); }
      .column-header { background: rgba(15,23,42,0.6) !important; border-color: #1f2937 !important; }
      .column-count { color: #7dd3fc !important; background: #083344 !important; border-color: #075985 !important; }

      .task-card { background: #0b1220 !important; border-color: #1f2937 !important; box-shadow: 0 1px 1px rgba(2, 6, 23, 0.6); }
      .task-card:hover { border-color: #0ea5e9 !important; box-shadow: 0 6px 16px rgba(14,165,233,0.18); }

      .droppable-hover { outline-color: rgba(125, 211, 252, 0.35) !important; background-color: rgba(14, 165, 233, 0.08) !important; }

      input[type="text"], input[type="date"], input:not([type]), .comment-input, textarea {
        background: #0b1220 !important; color: #e5e7eb !important; border-color: #334155 !important;
      }
      input::placeholder { color: #94a3b8 !important; }

      .modal-panel { background: #0f172a !important; border-color: #1f2937 !important; }
      .drawer { background: #0f172a !important; border-left: 1px solid #1f2937 !important; }

      /* Dark mode for description checkboxes */
      .desc-checkbox {
        background-color: #0b1220 !important;
        border-color: #475569 !important;
      }
      .desc-checkbox:hover {
        border-color: #10b981 !important;
      }
      .desc-checkbox:checked {
        background-color: #10b981 !important;
        border-color: #10b981 !important;
      }
      
      /* Light theme definitive tag chip overrides inside dark media query */
      html.theme-light body .tag-chip {
        background: #e0f2fe !important;
        color: #0369a1 !important;
        border-color: #bae6fd !important;
      }
      html.theme-light body .tag-chip[data-tag="mechanical"] { background:#fee2e2 !important; color:#991b1b !important; border-color:#fecaca !important; }
      html.theme-light body .tag-chip[data-tag="design"]     { background:#dbeafe !important; color:#1e40af !important; border-color:#bfdbfe !important; }
      html.theme-light body .tag-chip[data-tag="electrical"] { background:#fef3c7 !important; color:#92400e !important; border-color:#fde68a !important; }
      html.theme-light body .tag-chip[data-tag="programming"]{ background:#f3e8ff !important; color:#6b21a8 !important; border-color:#e9d5ff !important; }
      html.theme-light body .tag-chip[data-tag="website"]    { background:#cffafe !important; color:#155e75 !important; border-color:#a5f3fc !important; }
      html.theme-light body .tag-chip[data-tag="business"]   { background:#f1f5f9 !important; color:#475569 !important; border-color:#cbd5e1 !important; }
      html.theme-light body .tag-chip[data-tag="drive"]      { background:#fed7aa !important; color:#9a3412 !important; border-color:#fdba74 !important; }
      
      /* Light theme definitive dropdown overrides inside dark media query */
      html.theme-light .dropdown-btn {
        background: white !important;
        border-color: #d1d5db !important;
        color: #1e293b !important;
      }
      html.theme-light .dropdown-btn:hover {
        border-color: #93c5fd !important;
      }
      html.theme-light .dropdown-list {
        background: white !important;
        border-color: #d1d5db !important;
        box-shadow: 0 8px 24px rgba(2, 132, 199, 0.15);
      }
      html.theme-light .dropdown-list label:hover {
        background-color: #e0f2fe !important;
      }
      html.theme-light .dropdown-btn .placeholder {
        color: #94a3b8 !important;
      }
    }

    /* Old description styling utilities - No longer used but kept for backwards compatibility */
    /* These are no longer needed as the new system uses plain text only */

    /* Light theme definitive tag chip palette overrides (placed after dark media query) */
    html.theme-light body .tag-chip {
      background: #e0f2fe !important;
      color: #0369a1 !important;
      border-color: #bae6fd !important;
    }
    html.theme-light body .tag-chip[data-tag="mechanical"] { background:#fee2e2 !important; color:#991b1b !important; border-color:#fecaca !important; }
    html.theme-light body .tag-chip[data-tag="design"]     { background:#dbeafe !important; color:#1e40af !important; border-color:#bfdbfe !important; }
    html.theme-light body .tag-chip[data-tag="electrical"] { background:#fef3c7 !important; color:#92400e !important; border-color:#fde68a !important; }
    html.theme-light body .tag-chip[data-tag="programming"]{ background:#f3e8ff !important; color:#6b21a8 !important; border-color:#e9d5ff !important; }
    html.theme-light body .tag-chip[data-tag="website"]    { background:#cffafe !important; color:#155e75 !important; border-color:#a5f3fc !important; }
    html.theme-light body .tag-chip[data-tag="business"]   { background:#f1f5f9 !important; color:#475569 !important; border-color:#cbd5e1 !important; }
    html.theme-light body .tag-chip[data-tag="drive"]      { background:#fed7aa !important; color:#9a3412 !important; border-color:#fdba74 !important; }

    /* Toasts: Slide-in + Sound-ready */
    .toast-stack {
      position: fixed;
      right: 1rem;
      top: 1rem;
      display: grid;
      gap: 0.5rem;
      z-index: 10050;
      pointer-events: none;
    }
    .toast {
      pointer-events: auto;
      display: grid;
      grid-template-columns: auto 1fr auto;
      align-items: center;
      gap: 0.625rem;
      padding: 0.625rem 0.75rem;
      min-width: 240px;
      border-radius: 0.5rem;
      background: #ffffff;
      border: 1px solid #e6eef7;
      color: #073047;
      transform: translateX(16px);
      opacity: 0;
      transition: transform 200ms ease, opacity 200ms ease;
      box-shadow: 0 10px 24px rgba(2,132,199,0.08);
      will-change: transform, opacity;
    }
    .toast.show { transform: translateX(0); opacity: 1; }

    /* icon sizing */
    .toast-icon { width: 20px; height: 20px; flex: 0 0 20px; }

    /* variant color tokens */
    .toast.success { background: #f0fdf4; border-color: #bbf7d0; color: #065f46; }
    .toast.info    { background: #eff6ff; border-color: #bae6fd; color: #075985; }
    .toast.warn    { background: #fff7ed; border-color: #fde68a; color: #92400e; }
    .toast.error   { background: #fff1f2; border-color: #fecaca; color: #7f1d1d; }

    /* dismiss button */
    .toast button {
      background: transparent;
      border: none;
      padding: 0.25rem;
      cursor: pointer;
      color: inherit;
      opacity: 0.9;
    }
    .toast button:hover { opacity: 1; background: rgba(0,0,0,0.03); border-radius: 4px; }

    /* Dark theme */
    @media (prefers-color-scheme: dark) {
      .toast {
        background: #0b1220;
        border-color: #1f2937;
        color: #e6eef6;
        box-shadow: 0 10px 24px rgba(14,165,233,0.18);
      }
      .toast.success { background: #052e2b; border-color: #064e3b; color: #bbf7d0; }
      .toast.info    { background: #052335; border-color: #0c4a6e; color: #bae6fd; }
      .toast.warn    { background: #281a05; border-color: #78350f; color: #fde68a; }
      .toast.error   { background: #2b0b0b; border-color: #7f1d1d; color: #fecaca; }
    }

    /* Old Rich WYSIWYG Editor CSS - No longer used */
    /* Replaced by simpler Checklist + Notes system */

    /* --- Theme Overrides --- */
    /* Light Theme */
    html.theme-light body {
      background: linear-gradient(to bottom, #f0f9ff, white);
      color: #1e293b;
      color-scheme: light;
    }
    html.theme-light .column-section {
      background: white !important;
      border-color: #e2e8f0 !important;
      box-shadow: 0 1px 2px rgba(2, 6, 23, 0.05);
    }
    html.theme-light .task-card {
      background: white !important;
      border-color: #e2e8f0 !important;
    }
    html.theme-light .drawer {
      background: white !important;
    }
    html.theme-light input[type="text"], html.theme-light input[type="date"], 
    html.theme-light input:not([type]), html.theme-light .comment-input, html.theme-light textarea {
      background: white !important;
      color: #1e293b !important;
      border-color: #cbd5e1 !important;
    }
    html.theme-light .dropdown-btn {
      background: white !important;
      border-color: #d1d5db !important;
      color: #1e293b !important;
    }
    html.theme-light .dropdown-btn:hover {
      border-color: #93c5fd !important;
    }
    html.theme-light .dropdown-list {
      background: white !important;
      border-color: #d1d5db !important;
      box-shadow: 0 8px 24px rgba(2, 132, 199, 0.15);
    }
    html.theme-light .dropdown-list label:hover {
      background-color: #e0f2fe !important;
    }
    html.theme-light .dropdown-btn .placeholder {
      color: #94a3b8 !important;
    }

    /* Dark Theme */
    html.theme-dark body {
      background: linear-gradient(to bottom, #0b1220, #0a0f1a);
      color: #e5e7eb;
      color-scheme: dark;
    }
    html.theme-dark .dropdown-btn {
      background: #0b1220 !important;
      border-color: #334155 !important;
      color: #e5e7eb !important;
    }
    html.theme-dark .dropdown-btn:hover {
      border-color: #0ea5e9 !important;
    }
    html.theme-dark .dropdown-list {
      background: #0b1220 !important;
      border-color: #334155 !important;
    }
    html.theme-dark .dropdown-list label:hover {
      background-color: rgba(14,165,233,0.1) !important;
    }
    html.theme-dark .tag-chip {
      background: #0c4a6e !important;
      color: #e0f2fe !important;
      border-color: #075985 !important;
    }
    html.theme-dark .column-section {
      background: #0f172a !important;
      border-color: #1f2937 !important;
      box-shadow: 0 1px 2px rgba(2, 6, 23, 0.3);
    }
    html.theme-dark .task-card {
      background: #0b1220 !important;
      border-color: #1f2937 !important;
    }
    html.theme-dark .task-card:hover {
      border-color: #0ea5e9 !important;
    }
    html.theme-dark .drawer {
      background: #0f172a !important;
      border-left: 1px solid #1f2937 !important;
    }
    html.theme-dark input[type="text"], html.theme-dark input[type="date"],
    html.theme-dark input:not([type]), html.theme-dark .comment-input, html.theme-dark textarea {
      background: #0b1220 !important;
      color: #e5e7eb !important;
      border-color: #334155 !important;
    }
    html.theme-dark .desc-checkbox {
      background-color: #0b1220 !important;
      border-color: #475569 !important;
    }

    /* High Contrast Theme */
    html.theme-high-contrast body {
      background: #000000;
      color: #ffffff;
      color-scheme: dark;
    }
    html.theme-high-contrast .column-section {
      background: #1a1a1a !important;
      border: 2px solid #ffffff !important;
      box-shadow: none;
    }
    html.theme-high-contrast .column-header {
      background: #2a2a2a !important;
      border: 1px solid #ffffff !important;
    }
    html.theme-high-contrast .task-card {
      background: #0a0a0a !important;
      border: 2px solid #ffffff !important;
    }
    html.theme-high-contrast .task-card:hover {
      border-color: #ffff00 !important;
    }
    html.theme-high-contrast .drawer {
      background: #1a1a1a !important;
      border: 2px solid #ffffff !important;
    }
    html.theme-high-contrast input, html.theme-high-contrast textarea,
    html.theme-high-contrast select {
      background: #000000 !important;
      border: 2px solid #ffffff !important;
      color: #ffffff !important;
    }
    html.theme-high-contrast .tag-chip {
      background: #ffff00 !important;
      color: #000000 !important;
      border: 2px solid #ffffff !important;
    }
    html.theme-high-contrast .dropdown-btn {
      background: #000000 !important;
      border: 2px solid #ffffff !important;
      color: #ffffff !important;
    }
    html.theme-high-contrast .dropdown-list {
      background: #1a1a1a !important;
      border: 2px solid #ffffff !important;
    }
    html.theme-high-contrast button {
      border: 2px solid #ffffff !important;
    }

    /* Light Theme Overrides - Take precedence over dark: media queries when user selects Light */
    /* This ensures Light theme works correctly even when OS is in dark mode */
    
    /* Normalize backgrounds */
    html.theme-light .dark\:bg-slate-900 {
      background-color: white !important;
    }
    html.theme-light .dark\:bg-slate-950 {
      background-color: white !important;
    }
    
    /* Normalize borders */
    html.theme-light .dark\:border-slate-700 {
      border-color: #cbd5e1 !important;
    }
    html.theme-light .dark\:border-slate-800 {
      border-color: #e2e8f0 !important;
    }
    
    /* Normalize text colors - improve contrast */
    html.theme-light .dark\:text-slate-200 {
      color: #1e293b !important;
    }
    html.theme-light .dark\:text-slate-300 {
      color: #475569 !important;
    }
    html.theme-light .dark\:text-slate-400 {
      color: #64748b !important;
    }
    
    /* Normalize link/button colors */
    html.theme-light .dark\:text-sky-300 {
      color: #0369a1 !important;
    }
    html.theme-light .dark\:text-sky-400 {
      color: #0284c7 !important;
    }
    
    /* Normalize hover states */
    html.theme-light .dark\:hover\:bg-slate-800:hover {
      background-color: #f1f5f9 !important;
    }
    html.theme-light .dark\:hover\:bg-red-950:hover {
      background-color: #fee2e2 !important;
    }
    html.theme-light .dark\:hover\:text-slate-200:hover {
      color: #1e293b !important;
    }
    
    /* Ring colors */
    html.theme-light .dark\:ring-slate-900\/10 {
      --tw-ring-color: rgb(241 245 249 / 0.1) !important;
    }

    /* ===== FIX 1: Light theme tag chip colors - explicit overrides ===== */
    /* Base light theme tag chip */
    html.theme-light .tag-chip {
      background: #e0f2fe !important;
      color: #0369a1 !important;
      border-color: #bae6fd !important;
    }
    /* Per-team light theme tag colors */
    html.theme-light .tag-chip[data-tag="mechanical"] {
      background: #fee2e2 !important;
      color: #991b1b !important;
      border-color: #fecaca !important;
    }
    html.theme-light .tag-chip[data-tag="design"] {
      background: #dbeafe !important;
      color: #1e40af !important;
      border-color: #bfdbfe !important;
    }
    html.theme-light .tag-chip[data-tag="electrical"] {
      background: #fef3c7 !important;
      color: #92400e !important;
      border-color: #fde68a !important;
    }
    html.theme-light .tag-chip[data-tag="programming"] {
      background: #f3e8ff !important;
      color: #6b21a8 !important;
      border-color: #e9d5ff !important;
    }
    html.theme-light .tag-chip[data-tag="website"] {
      background: #cffafe !important;
      color: #155e75 !important;
      border-color: #a5f3fc !important;
    }
    html.theme-light .tag-chip[data-tag="business"] {
      background: #f1f5f9 !important;
      color: #475569 !important;
      border-color: #cbd5e1 !important;
    }
    html.theme-light .tag-chip[data-tag="drive"] {
      background: #fed7aa !important;
      color: #9a3412 !important;
      border-color: #fdba74 !important;
    }

    /* ===== FIX 2: Calendar controls visibility ===== */
    /* Per-comment calendar toggle button - strengthen icon color in light mode */
    html.theme-light .comment-toggle-calendar svg {
      color: #0369a1 !important;
    }
    html.theme-light .comment-toggle-calendar svg.text-amber-500 {
      color: #d97706 !important; /* stronger amber for pinned state */
    }
    html.theme-light .comment-toggle-calendar svg.text-slate-400 {
      color: #64748b !important; /* stronger slate for unpinned state */
    }
    /* Visible hover background for calendar toggle in both themes */
    html.theme-light .comment-toggle-calendar:hover {
      background-color: #e0f2fe !important;
    }
    html.theme-dark .comment-toggle-calendar:hover {
      background-color: rgba(14, 165, 233, 0.15) !important;
    }
    @media (prefers-color-scheme: dark) {
      .comment-toggle-calendar:hover {
        background-color: rgba(14, 165, 233, 0.15) !important;
      }
    }
    
    
    /* Legacy high contrast theme calendar picker - backwards compatibility for tasks page */
    html.theme-high-contrast input[type="date"]::-webkit-calendar-picker-indicator {
      filter: invert(1) brightness(2);
      opacity: 1;
      cursor: pointer;
    }

    /* ===== FIX 3: Comments input layout - prevent overflow on small screens ===== */
    .comments-section .flex.gap-2 {
      flex-wrap: wrap;
    }
    @media (max-width: 640px) {
      .comments-section .flex.gap-2 {
        flex-direction: column;
      }
      .comments-section .comment-input {
        width: 100%;
      }
      .comments-section .add-comment {
        width: 100%;
      }
    }

    /* Global Task Completion Bar */
    .completion-bar-container {
      background: white;
      border: 1px solid #e2e8f0;
      border-radius: 0.75rem;
      padding: 1rem;
      margin-top: 1rem;
      box-shadow: 0 1px 2px rgba(2, 6, 23, 0.05);
    }
    .completion-bar-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 0.5rem;
    }
    .completion-bar-label {
      font-size: 0.875rem;
      font-weight: 600;
      color: #0f172a;
    }
    .completion-bar-percentage {
      font-size: 0.875rem;
      font-weight: 700;
      color: #0369a1;
    }
    .completion-bar-track {
      width: 100%;
      height: 0.75rem;
      background: #e2e8f0;
      border-radius: 9999px;
      overflow: hidden;
      position: relative;
    }
    .completion-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #0ea5e9 0%, #0284c7 100%);
      border-radius: 9999px;
      transition: width 0.5s ease-in-out;
      box-shadow: 0 1px 3px rgba(14, 165, 233, 0.3);
    }
    .completion-bar-stats {
      display: flex;
      gap: 1.5rem;
      margin-top: 0.5rem;
      font-size: 0.75rem;
      color: #64748b;
    }
    .completion-bar-stat {
      display: flex;
      align-items: center;
      gap: 0.25rem;
    }
    .completion-bar-stat-dot {
      width: 0.5rem;
      height: 0.5rem;
      border-radius: 9999px;
    }
    .stat-dot-done { background: #10b981; }
    .stat-dot-progress { background: #f59e0b; }
    .stat-dot-todo { background: #6366f1; }
    .stat-dot-backlog { background: #94a3b8; }

    /* Dark theme for completion bar */
    @media (prefers-color-scheme: dark) {
      .completion-bar-container {
        background: #0f172a !important;
        border-color: #1f2937 !important;
      }
      .completion-bar-label {
        color: #e5e7eb !important;
      }
      .completion-bar-percentage {
        color: #7dd3fc !important;
      }
      .completion-bar-track {
        background: #1e293b !important;
      }
      .completion-bar-stats {
        color: #94a3b8 !important;
      }
    }

    /* Light theme overrides */
    html.theme-light .completion-bar-container {
      background: white !important;
      border-color: #e2e8f0 !important;
    }
    html.theme-light .completion-bar-label {
      color: #0f172a !important;
    }
    html.theme-light .completion-bar-percentage {
      color: #0369a1 !important;
    }
    html.theme-light .completion-bar-track {
      background: #e2e8f0 !important;
    }
    html.theme-light .completion-bar-stats {
      color: #64748b !important;
    }

    /* Dark theme overrides */
    html.theme-dark .completion-bar-container {
      background: #0f172a !important;
      border-color: #1f2937 !important;
    }
    html.theme-dark .completion-bar-label {
      color: #e5e7eb !important;
    }
    html.theme-dark .completion-bar-percentage {
      color: #7dd3fc !important;
    }
    html.theme-dark .completion-bar-track {
      background: #1e293b !important;
    }
    html.theme-dark .completion-bar-stats {
      color: #94a3b8 !important;
    }

    /* High contrast theme */
    html.theme-high-contrast .completion-bar-container {
      background: #1a1a1a !important;
      border: 2px solid #ffffff !important;
    }
    html.theme-high-contrast .completion-bar-label {
      color: #ffffff !important;
    }
    html.theme-high-contrast .completion-bar-percentage {
      color: #ffff00 !important;
    }
    html.theme-high-contrast .completion-bar-track {
      background: #000000 !important;
      border: 2px solid #ffffff !important;
    }
    html.theme-high-contrast .completion-bar-fill {
      background: #ffff00 !important;
    }
    html.theme-high-contrast .completion-bar-stats {
      color: #ffffff !important;
    }
  </style>
</head>
<body class="min-h-screen p-6">

<header class="max-w-7xl mx-auto mb-6 px-2">
  <div class="flex flex-col md:flex-row items-start md:items-center justify-between gap-3 md:gap-0 min-w-0">
    <div class="flex flex-col gap-1 w-full md:w-auto min-w-0">
      <h1 class="text-2xl md:text-3xl font-extrabold text-sky-800 leading-snug dark:text-sky-300">Trident Robotics — Task Board</h1>
      <p class="text-sm text-sky-600 dark:text-sky-400">A page made to track team tasks</p>
    </div>

    <div class="flex flex-col sm:flex-row items-start sm:items-center gap-2 sm:gap-3 w-full sm:w-auto min-w-0">
      <input id="filterInput" placeholder="Search tasks..." class="flex-1 sm:flex-none px-3 py-2 rounded-lg border border-slate-300 shadow-sm text-sm w-full sm:w-64 focus:outline-none focus:ring-2 focus:ring-sky-200 dark:bg-slate-950 dark:border-slate-700 dark:text-slate-200" />
      <!-- Subteam filter dropdown - custom single-select dropdown styled like tag dropdown -->
      <div class="dropdown w-full sm:w-48" id="subteamDropdown">
        <div class="dropdown-btn" id="subteamDropdownBtn"><span class="placeholder">All Subteams</span></div>
        <div class="dropdown-list" id="subteamDropdownList">
          <label><input type="radio" name="subteam" value="" checked /> <span>All Subteams</span></label>
          <label><input type="radio" name="subteam" value="Design" /> <span>Design</span></label>
          <label><input type="radio" name="subteam" value="Mechanical" /> <span>Mechanical</span></label>
          <label><input type="radio" name="subteam" value="Programming" /> <span>Programming</span></label>
          <label><input type="radio" name="subteam" value="Electrical" /> <span>Electrical</span></label>
          <label><input type="radio" name="subteam" value="Business" /> <span>Business</span></label>
          <label><input type="radio" name="subteam" value="Website" /> <span>Website</span></label>
          <label><input type="radio" name="subteam" value="Drive" /> <span>Drive</span></label>
        </div>
      </div>
      <!-- Added data-sound="whoosh" so only the whoosh plays (no default click) -->
      <button id="menuBtn" data-sound="whoosh" class="btn bg-sky-600 hover:bg-sky-700 text-white px-4 py-2 rounded-md font-semibold w-full sm:w-auto shadow-sm">Menu</button>
    </div>
  </div>

  <!-- Global Task Completion Bar -->
  <div class="completion-bar-container">
    <div class="completion-bar-header">
      <span class="completion-bar-label">Overall Progress</span>
      <span class="completion-bar-percentage" id="completionPercentage">0%</span>
    </div>
    <div class="completion-bar-track">
      <div class="completion-bar-fill" id="completionBarFill" style="width: 0%;"></div>
    </div>
    <div class="completion-bar-stats">
      <div class="completion-bar-stat">
        <span class="completion-bar-stat-dot stat-dot-done"></span>
        <span id="statDone">0 Done</span>
      </div>
      <div class="completion-bar-stat">
        <span class="completion-bar-stat-dot stat-dot-progress"></span>
        <span id="statProgress">0 In Progress</span>
      </div>
      <div class="completion-bar-stat">
        <span class="completion-bar-stat-dot stat-dot-todo"></span>
        <span id="statTodo">0 To Do</span>
      </div>
      <div class="completion-bar-stat">
        <span class="completion-bar-stat-dot stat-dot-backlog"></span>
        <span id="statBacklog">0 Backlog</span>
      </div>
    </div>
  </div>

  <!-- Add Task section -->
  <div class="mt-4 bg-white p-4 rounded-2xl shadow-sm border border-slate-200 ring-1 ring-slate-100 dark:bg-slate-900 dark:border-slate-800 dark:ring-slate-900/10">
    <div class="flex flex-col sm:flex-row gap-3 flex-wrap items-start sm:items-center">
      <input id="newTitle" class="flex-1 rounded-md border border-slate-300 px-3 py-2 w-full sm:w-auto focus:outline-none focus:ring-2 focus:ring-sky-200 dark:bg-slate-950 dark:border-slate-700 dark:text-slate-200" placeholder="Task title..." />
      <input id="newAssign" class="w-full sm:w-44 rounded-md border border-slate-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-sky-200 dark:bg-slate-950 dark:border-slate-700 dark:text-slate-200" placeholder="Assignee..." />
      <input id="newDue" type="date" class="w-full sm:w-44 rounded-md border border-slate-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-sky-200 dark:bg-slate-950 dark:border-slate-700 dark:text-slate-200" />

      <!-- Custom dropdown -->
      <div class="dropdown w-full sm:w-48" id="tagDropdown">
        <div class="dropdown-btn" id="dropdownBtn"><span class="placeholder">Select tags...</span></div>
        <div class="dropdown-list" id="dropdownList">
          <label><input type="checkbox" value="Design" /> <span>Design</span></label>
          <label><input type="checkbox" value="Mechanical" /> <span>Mechanical</span></label>
          <label><input type="checkbox" value="Programming" /> <span>Programming</span></label>
          <label><input type="checkbox" value="Electrical" /> <span>Electrical</span></label>
          <label><input type="checkbox" value="Business" /> <span>Business</span></label>
          <label><input type="checkbox" value="Website" /> <span>Website</span></label>
          <label><input type="checkbox" value="Drive" /> <span>Drive</span></label>
        </div>
      </div>

      <!-- New: Checklist + Notes Editor -->
      <div class="w-full">
        <label class="block text-sm font-medium text-slate-700 dark:text-slate-300 mb-2">Checklist</label>
        <div id="checklistItems" class="space-y-2 mb-3">
          <!-- Checklist items will be added here -->
        </div>
        <button id="addChecklistItemBtn" class="text-sm px-3 py-1.5 bg-sky-100 hover:bg-sky-200 text-sky-700 rounded-md dark:bg-sky-900 dark:text-sky-300 dark:hover:bg-sky-800">
          + Add Item
        </button>
        
        <label class="block text-sm font-medium text-slate-700 dark:text-slate-300 mt-4 mb-2">Notes (optional)</label>
        <textarea id="newNotes" 
                  class="w-full rounded-md border border-slate-300 px-3 py-2 text-sm min-h-[80px] focus:outline-none focus:ring-2 focus:ring-sky-200 dark:bg-slate-950 dark:border-slate-700 dark:text-slate-200" 
                  placeholder="Add any additional notes here..."></textarea>
      </div>

      <button id="addTaskBtn" class="btn bg-sky-600 hover:bg-sky-700 text-white px-4 py-2 rounded-md font-semibold w-full sm:w-auto shadow-sm">Add Task</button>
    </div>
  </div>
</header>

<main class="max-w-7xl mx-auto">
  <div id="board" class="grid grid-cols-1 md:grid-cols-4 gap-4"></div>
  <footer class="mt-12 text-center py-4 border-t border-slate-100 dark:border-slate-800 flex flex-col items-center gap-1">
    <img src="/assets/logo.png" alt="Trident Robotics Logo" class="h-6 w-6" />
    <span class="text-sky-600 dark:text-sky-400 text-sm">© 2025 Trident Robotics — Task Board</span>
    <span class="text-xs text-sky-400">Internal team dashboard</span>
  </footer>
</main>

<!-- Toast stack -->
<div id="toastStack" class="toast-stack" aria-live="polite" aria-atomic="true"></div>

<!-- Drawer -->
<div class="drawer-overlay" id="drawerOverlay"></div>
<div class="drawer" id="drawer">
  <div class="p-6">
    <div class="flex items-center justify-between mb-4">
      <h2 class="text-xl font-bold text-slate-800 dark:text-slate-300">Menu</h2>
      <button id="closeDrawerBtn" class="text-slate-600 dark:text-slate-400 hover:text-slate-800 dark:hover:text-slate-200">
        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
      </button>
    </div>
    <div>
      <h3 class="text-lg font-semibold text-slate-700 dark:text-slate-300 mb-3">Trash</h3>
      <div id="trashList" class="space-y-2"></div>
    </div>
    <div>
      <h3 class="text-lg font-semibold text-slate-700 dark:text-slate-300 mb-3">Archive</h3>
      <div id="archiveList" class="space-y-2"></div>
    </div>
  </div>
</div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/10.1.0/firebase-app.js";
import { getFirestore, collection, getDocs, addDoc, setDoc, doc, deleteDoc, getDoc, writeBatch } from "https://www.gstatic.com/firebasejs/10.1.0/firebase-firestore.js";

const firebaseConfig = {
  apiKey: "AIzaSyC7k3xdqmsuYOEBBDbDfnrmuaebLaHGWZI",
  authDomain: "tridenttaskboard.firebaseapp.com",
  projectId: "tridenttaskboard",
  storageBucket: "tridenttaskboard.firebasestorage.appspot.com",
  messagingSenderId: "143400263387",
  appId: "1:143400263387:web:66ed521ae75af588e836fe",
  measurementId: "G-F12DRDCX87"
};

const app = initializeApp(firebaseConfig);
const db = getFirestore(app);
window.firestoreDB = db;

/* Authentication Helper */
function isUserSignedIn() {
  const credential = localStorage.getItem('g_credential_v1');
  if (!credential) return false;
  try {
    // Basic check if credential exists and is not expired
    if (typeof jwt_decode === 'function') {
      const decoded = jwt_decode(credential);
      // Check if token is expired
      if (decoded.exp && decoded.exp * 1000 < Date.now()) {
        return false;
      }
    }
    return true;
  } catch (e) {
    return false;
  }
}

function getUserEmail() {
  const credential = localStorage.getItem('g_credential_v1');
  if (!credential) return null;
  try {
    if (typeof jwt_decode === 'function') {
      const decoded = jwt_decode(credential);
      return decoded.email || null;
    }
  } catch (e) {
    return null;
  }
  return null;
}

/* DOM refs */
const board = document.getElementById("board");
const filterInput = document.getElementById("filterInput");
const addBtn = document.getElementById("addTaskBtn");
const menuBtn = document.getElementById("menuBtn");
const drawer = document.getElementById("drawer");
const drawerOverlay = document.getElementById("drawerOverlay");
const closeDrawerBtn = document.getElementById("closeDrawerBtn");

/* Drawer toggle */
menuBtn.onclick = () => {
  drawer.classList.add("open");
  drawerOverlay.classList.add("active");
  // Removed manual Sound.whoosh(); it's now handled by data-sound="whoosh"
  renderDrawer();
};
closeDrawerBtn.onclick = () => { drawer.classList.remove("open"); drawerOverlay.classList.remove("active"); };
drawerOverlay.onclick = () => { drawer.classList.remove("open"); drawerOverlay.classList.remove("active"); };

/* Tag dropdown */
const dropdownBtn = document.getElementById("dropdownBtn");
const dropdownList = document.getElementById("dropdownList");
let selectedTags = [];

/* Due date formatter with coloring */
function formatDueDate(dueStr) {
  if (!dueStr) return '<span class="text-xs text-slate-500 dark:text-slate-400">no due</span>';
  const dueDate = new Date(dueStr + "T23:59:59");
  const now = new Date();
  const diffMs = dueDate - now;
  const diffHours = diffMs / 36e5;
  let cls = "text-xs text-slate-500 dark:text-slate-400";
  if (diffMs < 0) cls = "text-xs due-overdue";
  else if (diffHours <= 24) cls = "text-xs due-soon";
  return `<span class="${cls}">${dueStr}</span>`;
}

/* Dropdown behavior */
dropdownBtn.addEventListener("click", () => {
  dropdownList.style.display = dropdownList.style.display === "block" ? "none" : "block";
});
document.addEventListener("click", e => {
  const root = document.getElementById("tagDropdown");
  if (!root.contains(e.target)) { dropdownList.style.display = "none"; updateDropdownBtn(); }
});
function updateDropdownBtn() {
  dropdownBtn.innerHTML = selectedTags.length ? chipsHTML(selectedTags) : '<span class="placeholder">Select tags...</span>';
}
dropdownList.querySelectorAll("input[type=checkbox]").forEach(cb => {
  cb.addEventListener("change", () => {
    selectedTags = Array.from(dropdownList.querySelectorAll("input:checked")).map(c => c.value);
    updateDropdownBtn();
  });
});

/* Subteam filter dropdown - single-select behavior */
const subteamDropdownBtn = document.getElementById("subteamDropdownBtn");
const subteamDropdownList = document.getElementById("subteamDropdownList");
let selectedSubteam = ""; // "" means "All Subteams"

// Toggle dropdown visibility on button click
subteamDropdownBtn.addEventListener("click", () => {
  subteamDropdownList.style.display = subteamDropdownList.style.display === "block" ? "none" : "block";
});

// Close dropdown when clicking outside
document.addEventListener("click", e => {
  const root = document.getElementById("subteamDropdown");
  if (!root.contains(e.target)) {
    subteamDropdownList.style.display = "none";
  }
});

// Update button text when radio selection changes
function updateSubteamDropdownBtn() {
  const checkedRadio = subteamDropdownList.querySelector("input[type=radio]:checked");
  // Get label text from the span next to the radio button
  const labelSpan = checkedRadio ? checkedRadio.nextElementSibling : null;
  const label = labelSpan ? labelSpan.textContent : "All Subteams";
  subteamDropdownBtn.innerHTML = `<span>${escHtml(label)}</span>`;
}

// Handle radio button changes
subteamDropdownList.querySelectorAll("input[type=radio]").forEach(radio => {
  radio.addEventListener("change", () => {
    selectedSubteam = radio.value;
    updateSubteamDropdownBtn();
    renderBoard(); // Re-render board with new filter
    subteamDropdownList.style.display = "none"; // Close dropdown after selection
  });
});

/* Description helpers - New Checklist + Notes Model */
function escHtml(str) {
  return String(str ?? "")
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll("'", "&#39;")
    .replaceAll('"', "&quot;")
    .replaceAll("`", "&#96;");
}

/* Create descModel from checklist items and notes */
function createDescModel(items, notes) {
  return {
    items: items || [],
    notes: notes || ""
  };
}

/* Generate HTML from descModel for card display */
function generateDescHtml(descModel, taskId) {
  if (!descModel || (!descModel.items?.length && !descModel.notes)) return "";
  
  let html = "";
  
  // Render checklist items
  if (descModel.items && descModel.items.length > 0) {
    descModel.items.forEach((item, idx) => {
      const checked = item.checked ? "checked" : "";
      const text = escHtml(item.text || "");
      html += `
        <label class="flex items-start gap-2 py-0.5 select-none cursor-pointer">
          <input type="checkbox" class="desc-checkbox mt-0.5"
            data-task-id="${escHtml(taskId)}" data-item-index="${idx}" ${checked} />
          <span class="leading-tight whitespace-pre-wrap break-words">${text}</span>
        </label>
      `;
    });
  }
  
  // Render notes
  if (descModel.notes) {
    const notesHtml = escHtml(descModel.notes).replace(/\n/g, "<br>");
    html += `<div class="mt-2 pt-2 border-t border-slate-200 dark:border-slate-700 text-sm">${notesHtml}</div>`;
  }
  
  return html;
}

/* Generate plain text from descModel for search/filter */
function generateDescText(descModel) {
  if (!descModel) return "";
  
  let text = "";
  
  // Add checklist items
  if (descModel.items && descModel.items.length > 0) {
    text += descModel.items.map(item => item.text || "").join(" ");
  }
  
  // Add notes
  if (descModel.notes) {
    text += " " + descModel.notes;
  }
  
  return text.trim();
}

/* Parse old description string to descModel for migration */
function parseOldDescription(description) {
  if (!description) return { items: [], notes: "" };
  
  const lines = String(description).split(/\r?\n/);
  const items = [];
  const noteLines = [];
  
  lines.forEach(line => {
    const match = line.match(/^\s*-\s*\[([ xX])\]\s*(.*)$/);
    if (match) {
      const checked = match[1].toLowerCase() === "x";
      const text = match[2] || "";
      items.push({ text, checked });
    } else if (line.trim()) {
      noteLines.push(line);
    }
  });
  
  return {
    items,
    notes: noteLines.join("\n")
  };
}

/* Toggle checkbox in descModel */
function toggleCheckboxInModel(descModel, itemIndex) {
  if (!descModel || !descModel.items || itemIndex < 0 || itemIndex >= descModel.items.length) {
    return descModel;
  }
  
  const newModel = {
    items: descModel.items.map((item, idx) => {
      if (idx === itemIndex) {
        return { ...item, checked: !item.checked };
      }
      return item;
    }),
    notes: descModel.notes
  };
  
  return newModel;
}

/* Old sanitizeHTML function - No longer needed with plain text system */

function renderDescriptionHTML(desc, taskId, descModel) {
  // Use new model if available
  if (descModel && (descModel.items?.length || descModel.notes)) {
    return generateDescHtml(descModel, taskId);
  }
  
  // Fall back to old format for backwards compatibility
  const text = String(desc || "");
  if (!text.trim()) return "";
  const lines = text.split(/\r?\n/);
  return lines.map((line, idx) => {
    const m = line.match(/^\s*-\s*\[([ xX])\]\s*(.*)$/);
    if (m) {
      const checked = m[1].toLowerCase() === "x";
      const item = m[2] || "";
      const sanitizedItem = escHtml(item);
      return `
        <label class="flex items-start gap-2 py-0.5 select-none cursor-pointer">
          <input type="checkbox" class="desc-checkbox mt-0.5"
            data-task-id="${escHtml(taskId)}" data-line-index="${idx}" ${checked ? "checked" : ""} />
          <span class="leading-tight whitespace-pre-wrap break-words">${sanitizedItem}</span>
        </label>
      `;
    }
    const sanitizedLine = escHtml(line);
    return `<div class="leading-tight py-0.5 whitespace-pre-wrap break-words">${sanitizedLine}</div>`;
  }).join("");
}
function toggleChecklistLine(desc, lineIndex) {
  const lines = String(desc || "").split(/\r?\n/);
  if (lineIndex < 0 || lineIndex >= lines.length) return desc;
  const line = lines[lineIndex];
  const m = line.match(/^(\s*-\s*\[)([ xX])(\]\s*)(.*)$/);
  if (!m) return desc;
  const newMark = m[2].toLowerCase() === "x" ? " " : "x";
  lines[lineIndex] = `${m[1]}${newMark}${m[3]}${m[4]}`;
  return lines.join("\n");
}
// Expose to window for use by tasks-checklist.js
window.toggleChecklistLine = toggleChecklistLine;

/* Data loading */
async function loadTasks() {
  const snapshot = await getDocs(collection(db, "tasks"));
  const data = {
    columns: {
      backlog: { title: "Backlog", tasks: [] },
      todo: { title: "To Do", tasks: [] },
      inprogress: { title: "In Progress", tasks: [] },
      done: { title: "Done", tasks: [] }
    },
    order: ["backlog", "todo", "inprogress", "done"]
  };

  snapshot.forEach(docSnap => {
    const t = docSnap.data();
    if (t.deleted || t.archived) return; // hide from board
    const col = t.column || "backlog";
    (data.columns[col] ??= { title: col, tasks: [] }).tasks.push({ id: docSnap.id, ...t });
  });

  await checkAutoArchive(data);
  return data;
}

/* Auto-archive done tasks based on due status */
async function checkAutoArchive(data) {
  const now = Date.now();
  const oneDay = 1 * 24 * 60 * 60 * 1000;
  const sevenDays = 7 * 24 * 60 * 60 * 1000;
  const batch = writeBatch(db);
  let needsUpdate = false;

  for (const task of (data.columns.done?.tasks || [])) {
    if (task.completedAt && !task.archived) {
      // Determine archive threshold based on whether task was overdue when completed
      let archiveThreshold = sevenDays; // Default: 7 days for tasks completed on time
      
      if (task.wasOverdueWhenCompleted) {
        // Task was overdue: archive after 1 day
        archiveThreshold = oneDay;
      }
      
      if ((now - task.completedAt) > archiveThreshold) {
        batch.update(doc(db, "tasks", task.id), { archived: true, archivedAt: now });
        needsUpdate = true;
      }
    }
  }
  if (needsUpdate) await batch.commit();
}

/* Save task (safe payload) */
async function saveTask(task, col) {
  const payload = {
    id: task.id,
    title: task.title || "",
    assignee: task.assignee || "Unassigned",
    due: task.due || "",
    tags: Array.isArray(task.tags) ? task.tags : [],
    order: typeof task.order === "number" ? task.order : 0,
    column: col
  };
  
  // Include new model fields if present
  if (task.descModel) {
    payload.descModel = task.descModel;
    payload.descHtml = generateDescHtml(task.descModel, task.id);
    payload.descText = generateDescText(task.descModel);
  } else {
    // Keep old description for backwards compatibility
    payload.description = task.description || "";
  }
  
  if (Array.isArray(task.comments) && task.comments.length > 0) payload.comments = task.comments;
  
  await setDoc(doc(db, "tasks", task.id), payload, { merge: true });
}

async function deleteTaskFirestore(taskId) {
  // Delete the task document
  await deleteDoc(doc(db, "tasks", taskId));
}

/* Update global completion bar */
function updateCompletionBar(data) {
  // Calculate task counts by column
  const counts = {
    backlog: data.columns.backlog?.tasks.length || 0,
    todo: data.columns.todo?.tasks.length || 0,
    inprogress: data.columns.inprogress?.tasks.length || 0,
    done: data.columns.done?.tasks.length || 0
  };
  
  const totalTasks = counts.backlog + counts.todo + counts.inprogress + counts.done;
  const completedTasks = counts.done;
  const percentage = totalTasks > 0 ? Math.round((completedTasks / totalTasks) * 100) : 0;
  
  // Update percentage display
  const percentageEl = document.getElementById('completionPercentage');
  if (percentageEl) {
    percentageEl.textContent = `${percentage}%`;
  }
  
  // Update progress bar fill
  const fillEl = document.getElementById('completionBarFill');
  if (fillEl) {
    fillEl.style.width = `${percentage}%`;
  }
  
  // Update statistics
  const statDone = document.getElementById('statDone');
  const statProgress = document.getElementById('statProgress');
  const statTodo = document.getElementById('statTodo');
  const statBacklog = document.getElementById('statBacklog');
  
  if (statDone) statDone.textContent = `${counts.done} Done`;
  if (statProgress) statProgress.textContent = `${counts.inprogress} In Progress`;
  if (statTodo) statTodo.textContent = `${counts.todo} To Do`;
  if (statBacklog) statBacklog.textContent = `${counts.backlog} Backlog`;
}

/* Render board */
async function renderBoard() {
  const data = await loadTasks();
  
  // Update completion bar with loaded data
  updateCompletionBar(data);
  
  board.innerHTML = "";
  data.order.forEach(colId => {
    const col = data.columns[colId];
    const colEl = document.createElement("section");
    colEl.className = "column-section";
    colEl.innerHTML = `
      <div class="column-header">
        <h2 class="text-base font-semibold text-slate-700 dark:text-slate-200">${col.title}</h2>
        <div class="column-count">${col.tasks.length}</div>
      </div>
      <div class="task-list min-h-[120px] space-y-3" data-col="${colId}"></div>
    `;
    board.appendChild(colEl);

    const list = colEl.querySelector(".task-list");
    col.tasks
      .filter(t => {
        // Text search filter
        const f = (filterInput.value || "").toLowerCase();
        const matchesText = !f
          || (t.title || "").toLowerCase().includes(f)
          || (t.assignee || "").toLowerCase().includes(f)
          || (t.descText || t.description || "").toLowerCase().includes(f)
          || (t.tags || []).some(tag => tag.toLowerCase().includes(f));
        
        // Subteam filter - check if task has any tag matching the selected subteam
        // selectedSubteam is now a global variable set by the custom dropdown
        const matchesSubteam = !selectedSubteam
          || (t.tags || []).some(tag => tag.toLowerCase() === selectedSubteam.toLowerCase());
        
        // Both filters must pass (AND logic)
        return matchesText && matchesSubteam;
      })
      .sort((a, b) => (a.order ?? 0) - (b.order ?? 0))
      .forEach(task => list.appendChild(createTaskEl(task, colId)));

    makeDroppable(list);
  });
}

/* Create Task Card */
function createTaskEl(task, colId) {
  const div = document.createElement("div");
  div.className = "task-card";
  div.draggable = true;
  div.dataset.id = task.id;
  div.dataset.col = colId;

  const assignee = task.assignee || "Unassigned";
  
  // Use descHtml if available, otherwise generate from model or fall back to old format
  let descHtml = task.descHtml || "";
  if (!descHtml) {
    descHtml = renderDescriptionHTML(task.description || "", task.id, task.descModel);
  }

  div.innerHTML = `
    <div class="flex items-start justify-between gap-2">
      <div>
        <h3 class="font-medium text-slate-800 dark:text-slate-200">${task.title}</h3>
        <div class="text-xs text-slate-500 dark:text-slate-400">${assignee} • ${formatDueDate(task.due || "")}</div>
      </div>
      <div class="flex gap-2 shrink-0">
        <button class="text-xs px-2 py-1 border border-slate-300 rounded-md hover:bg-slate-50 dark:border-slate-700 dark:text-slate-300 dark:hover:bg-slate-800 edit-btn">Edit</button>
        <button class="text-xs px-2 py-1 border border-red-200 rounded-md text-red-600 hover:bg-red-50 dark:border-red-900 dark:text-red-400 dark:hover:bg-red-950 del-btn">Delete</button>
      </div>
    </div>

    <div class="mt-2 flex gap-2 flex-wrap">
      ${(task.tags || []).map(t => `<span class="tag-chip" data-tag="${escHtml(String(t).toLowerCase())}">${escHtml(String(t))}</span>`).join("")}
    </div>

    ${descHtml ? `
      <div class="mt-3 border border-slate-100 dark:border-slate-800 rounded-md p-2 bg-slate-50 dark:bg-slate-900" data-role="description">
        ${descHtml}
      </div>
    ` : ""}

    <!-- Archive button positioned at bottom-right -->
    <button class="archive-btn absolute bottom-2 right-2 p-1.5 text-slate-400 hover:text-slate-600 dark:hover:text-slate-300 hover:bg-slate-100 dark:hover:bg-slate-800 rounded transition-colors" 
            aria-label="Archive" 
            title="Archive">
      <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4"/>
      </svg>
    </button>

    <div class="mt-3">
      <button class="text-xs text-sky-600 dark:text-sky-400 underline toggle-comments">Show Notes</button>
      <div class="comments-section hidden mt-2 border-t border-slate-100 dark:border-slate-800 pt-2 space-y-2">
        <div class="comments-list text-sm text-slate-800 dark:text-slate-200">
          ${(task.comments || []).map((c, idx) => {
            const dateStr = c.timestamp
              ? new Date(c.timestamp).toLocaleString([], { month: "short", day: "numeric", year: "numeric", hour: "2-digit", minute: "2-digit" })
              : "";
            const authorStr = c.author || "Anonymous";
            const safeText = c.text || "";
            const textHtml = safeText ? `<span class="block">${safeText}</span>` : "";
            const showOnCal = c.showOnCalendar || false;
            const pinIcon = showOnCal 
              ? '<svg class="w-4 h-4 text-amber-500" fill="currentColor" viewBox="0 0 20 20"><path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.07 3.292a1 1 0 00.95.69h3.462c.969 0 1.371 1.24.588 1.81l-2.8 2.034a1 1 0 00-.364 1.118l1.07 3.292c.3.921-.755 1.688-1.54 1.118l-2.8-2.034a1 1 0 00-1.175 0l-2.8 2.034c-.784.57-1.838-.197-1.539-1.118l1.07-3.292a1 1 0 00-.364-1.118L2.98 8.72c-.783-.57-.38-1.81.588-1.81h3.461a1 1 0 00.951-.69l1.07-3.292z"/></svg>'
              : '<svg class="w-4 h-4 text-slate-400" fill="none" stroke="currentColor" viewBox="0 0 20 20"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11.049 2.927c.3-.921 1.603-.921 1.902 0l1.519 4.674a1 1 0 00.95.69h4.915c.969 0 1.371 1.24.588 1.81l-3.976 2.888a1 1 0 00-.363 1.118l1.518 4.674c.3.922-.755 1.688-1.538 1.118l-3.976-2.888a1 1 0 00-1.176 0l-3.976 2.888c-.783.57-1.838-.197-1.538-1.118l1.518-4.674a1 1 0 00-.363-1.118l-3.976-2.888c-.784-.57-.38-1.81.588-1.81h4.914a1 1 0 00.951-.69l1.519-4.674z"/></svg>';
            return `
              <div class="border border-slate-100 dark:border-slate-800 rounded-md p-2 bg-slate-50 dark:bg-slate-900 comment-item" data-ts="${c.timestamp || ''}" data-idx="${idx}">
                <div class="flex items-start justify-between gap-2">
                  <div class="flex-1">
                    ${textHtml}
                    <span class="text-xs text-slate-400">${authorStr} • ${dateStr}</span>
                  </div>
                  <div class="flex items-center gap-1 shrink-0">
                    <button class="comment-toggle-calendar p-1 rounded hover:bg-slate-100 dark:hover:bg-slate-800" title="${showOnCal ? 'Hide from calendar' : 'Show on calendar'}">
                      ${pinIcon}
                    </button>
                    <button class="comment-edit p-1 rounded hover:bg-slate-100 dark:hover:bg-slate-800" title="Edit">
                      <svg class="w-4 h-4 text-slate-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                          d="M11 5h2m-9 9l2 2 12-12a2.121 2.121 0 10-3-3L3 13l-1 4 4-1z" />
                      </svg>
                    </button>
                    <button class="comment-delete p-1 rounded hover:bg-red-50 dark:hover:bg-red-950" title="Delete">
                      <svg class="w-4 h-4 text-red-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                          d="M6 18L18 6M6 6l12 12" />
                      </svg>
                    </button>
                  </div>
                </div>
              </div>
            `;
          }).join("")}
        </div>
        <div class="flex flex-col gap-2 mt-2">
          <div class="flex gap-2">
            <input type="text" placeholder="Add note..."
              class="comment-input flex-1 border border-slate-300 dark:border-slate-700 dark:bg-slate-950 dark:text-slate-200 rounded-md px-2 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-sky-200" />
            <button class="add-comment px-2 py-1 bg-sky-600 text-white rounded-md text-xs hover:bg-sky-700">Add</button>
          </div>
          <label class="flex items-center gap-2 text-xs text-slate-600 dark:text-slate-400">
            <input type="checkbox" class="show-on-calendar-checkbox w-3 h-3 rounded" />
            <span>Show on calendar</span>
          </label>
        </div>
      </div>
    </div>
  `;

  /* Delete (soft) */
  div.querySelector(".del-btn").onclick = async () => {
    if (!confirm(`Delete "${task.title}"?`)) return;
    div.classList.add("transition", "duration-300", "opacity-0", "translate-x-4");
    setTimeout(async () => {
      await setDoc(doc(db, "tasks", task.id), {
        deleted: true,
        deletedAt: Date.now(),
        deletedBy: getCurrentUserName()
      }, { merge: true });
      div.remove();
      renderBoard();
    }, 300);
  };

  /* Archive */
  div.querySelector(".archive-btn").onclick = async (e) => {
    e.stopPropagation(); // Prevent event bubbling
    if (!confirm(`Archive "${task.title}"?\n\nArchived tasks will be moved to the Archive section in the menu.`)) return;
    
    div.classList.add("transition", "duration-300", "opacity-0", "scale-95");
    setTimeout(async () => {
      try {
        await setDoc(doc(db, "tasks", task.id), {
          archived: true,
          archivedAt: Date.now()
        }, { merge: true });
        div.remove();
        renderBoard();
        showToast('success', `Task "${task.title}" archived successfully!`);
      } catch (err) {
        console.error("Failed to archive task:", err);
        showToast('error', `Failed to archive task: ${err?.message || err}`);
        div.classList.remove("transition", "duration-300", "opacity-0", "scale-95");
      }
    }, 300);
  };

  /* Edit task */
  div.querySelector(".edit-btn").onclick = () => openEditModal(task, colId);

  /* Toggle comments visibility */
  div.querySelector(".toggle-comments").onclick = (e) => {
    const section = div.querySelector(".comments-section");
    const isHidden = section.classList.toggle("hidden");
    e.target.textContent = isHidden ? "Show Notes" : "Hide Notes";
  };

  /* Add comment (with optional showOnCalendar flag) */
  div.querySelector(".add-comment").onclick = async () => {
    const input = div.querySelector(".comment-input");
    const text = (input.value || "").trim();
    if (!text) return;

    const showOnCalCheckbox = div.querySelector(".show-on-calendar-checkbox");
    const showOnCalendar = showOnCalCheckbox ? showOnCalCheckbox.checked : false;

    const button = div.querySelector(".add-comment");
    button.disabled = true;
    const originalLabel = button.textContent;
    button.textContent = "Adding...";

    try {
      const newComment = { timestamp: Date.now(), author: getCurrentUserName(), text, showOnCalendar };
      const updatedComments = [ ...(task.comments || []), newComment ];
      await setDoc(doc(db, "tasks", task.id), { comments: updatedComments }, { merge: true });

      task.comments = updatedComments;
      input.value = "";
      if (showOnCalCheckbox) showOnCalCheckbox.checked = false;
      renderBoard();
    } catch (err) {
      console.error("Failed to add comment:", err);
      alert(`Failed to add comment: ${err.message || err}`);
    } finally {
      button.disabled = false;
      button.textContent = originalLabel || "Add";
    }
  };

  /* Edit an existing comment (pencil icon) */
  div.querySelectorAll(".comment-edit").forEach(btn => {
    btn.onclick = async () => {
      const container = btn.closest(".comment-item");
      if (!container) return;
      const ts = parseInt(container.dataset.ts || "0", 10);
      const idx = parseInt(container.dataset.idx || "-1", 10);

      let existing = null;
      if (ts) existing = (task.comments || []).find(c => c.timestamp === ts);
      if (!existing && idx >= 0) existing = (task.comments || [])[idx];

      const newText = prompt("Edit note:", existing?.text || "");
      if (newText === null) return; // cancel
      const trimmed = newText.trim();
      if (!trimmed) return;

      const updated = (task.comments || []).map((c, i) =>
        (ts ? c.timestamp === ts : i === idx) ? { ...c, text: trimmed } : c
      );

      try {
        await setDoc(doc(db, "tasks", task.id), { comments: updated }, { merge: true });
        task.comments = updated;
        renderBoard();
      } catch (err) {
        console.error("Failed to edit comment:", err);
        alert(`Failed to edit comment: ${err.message || err}`);
      }
    };
  });

  /* Delete an existing comment (red X) */
  div.querySelectorAll(".comment-delete").forEach(btn => {
    btn.onclick = async () => {
      const container = btn.closest(".comment-item");
      if (!container) return;
      const ts = parseInt(container.dataset.ts || "0", 10);
      const idx = parseInt(container.dataset.idx || "-1", 10);

      if (!confirm("Delete this note?")) return;

      const updated = (task.comments || []).filter((c, i) => ts ? c.timestamp !== ts : i !== idx);

      try {
        await setDoc(doc(db, "tasks", task.id), { comments: updated }, { merge: true });
        task.comments = updated;
        renderBoard();
      } catch (err) {
        console.error("Failed to delete comment:", err);
        alert(`Failed to delete comment: ${err.message || err}`);
      }
    };
  });

  /* Toggle showOnCalendar flag for existing comments (star/pin icon) */
  div.querySelectorAll(".comment-toggle-calendar").forEach(btn => {
    btn.onclick = async () => {
      const container = btn.closest(".comment-item");
      if (!container) return;
      const ts = parseInt(container.dataset.ts || "0", 10);
      const idx = parseInt(container.dataset.idx || "-1", 10);

      let existing = null;
      if (ts) existing = (task.comments || []).find(c => c.timestamp === ts);
      if (!existing && idx >= 0) existing = (task.comments || [])[idx];

      const updated = (task.comments || []).map((c, i) => {
        if (ts ? c.timestamp === ts : i === idx) {
          return { ...c, showOnCalendar: !c.showOnCalendar };
        }
        return c;
      });

      try {
        await setDoc(doc(db, "tasks", task.id), { comments: updated }, { merge: true });
        task.comments = updated;
        renderBoard();
      } catch (err) {
        console.error("Failed to toggle calendar visibility:", err);
        alert(`Failed to update: ${err.message || err}`);
      }
    };
  });

  /* Description checkbox toggles (event delegation within card) */
  div.addEventListener("change", async (e) => {
    const cb = e.target.closest(".desc-checkbox");
    if (!cb) return;
    
    // Check if using new model
    const itemIndex = parseInt(cb.getAttribute("data-item-index"), 10);
    if (!Number.isNaN(itemIndex) && task.descModel) {
      // New model path
      try {
        const newModel = toggleCheckboxInModel(task.descModel, itemIndex);
        const updatePayload = {
          descModel: newModel,
          descHtml: generateDescHtml(newModel, task.id),
          descText: generateDescText(newModel)
        };
        
        await setDoc(doc(db, "tasks", task.id), updatePayload, { merge: true });
        task.descModel = newModel;
        task.descHtml = updatePayload.descHtml;
        task.descText = updatePayload.descText;
        
        const container = div.querySelector('[data-role="description"]');
        if (container) container.innerHTML = updatePayload.descHtml;
      } catch (err) {
        console.error("Failed to update description:", err);
        alert(`Failed to update description: ${err.message || err}`);
        cb.checked = !cb.checked;
      }
      return;
    }
    
    // Old format fallback (for backwards compatibility)
    const lineIndex = parseInt(cb.getAttribute("data-line-index"), 10);
    if (Number.isNaN(lineIndex)) return;

    const newDesc = toggleChecklistLine(task.description || "", lineIndex);
    try {
      await setDoc(doc(db, "tasks", task.id), { description: newDesc }, { merge: true });
      task.description = newDesc;
      const container = div.querySelector('[data-role="description"]');
      if (container) container.innerHTML = renderDescriptionHTML(newDesc, task.id);
    } catch (err) {
      console.error("Failed to update description:", err);
      alert(`Failed to update description: ${err.message || err}`);
      cb.checked = !cb.checked;
    }
  });

  makeDraggable(div);
  return div;
}

/* Edit modal */
function openEditModal(task, colId) {
  const modal = document.createElement("div");
  modal.className = "fixed inset-0 bg-black/30 flex items-center justify-center z-50 p-4";
  modal.innerHTML = `
    <div class="bg-white p-6 rounded-xl shadow-xl w-80 max-h-[90vh] overflow-y-auto space-y-3 border border-slate-200 ring-1 ring-slate-100 modal-panel dark:bg-slate-900 dark:border-slate-800">
      <h3 class="text-lg font-semibold text-slate-700 dark:text-slate-200 mb-2">Edit Task</h3>
      <input id="editTitle" class="w-full rounded-md border border-slate-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-sky-200 dark:bg-slate-950 dark:border-slate-700 dark:text-slate-200" placeholder="Title" />
      <input id="editAssign" class="w-full rounded-md border border-slate-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-sky-200 dark:bg-slate-950 dark:border-slate-700 dark:text-slate-200" placeholder="Assignee" />
      <input id="editDue" type="date" class="w-full rounded-md border border-slate-300 px-3 py-2 focus:outline-none focus:ring-2 focus:ring-sky-200 dark:bg-slate-950 dark:border-slate-700 dark:text-slate-200" />

      <!-- Checklist + Notes Editor -->
      <label class="block text-sm font-medium text-slate-600 dark:text-slate-300 mb-2">Checklist</label>
      <div id="editChecklistItems" class="space-y-2 mb-3">
        <!-- Checklist items will be added here -->
      </div>
      <button id="editAddChecklistItemBtn" class="text-sm px-3 py-1.5 bg-sky-100 hover:bg-sky-200 text-sky-700 rounded-md dark:bg-sky-900 dark:text-sky-300 dark:hover:bg-sky-800">
        + Add Item
      </button>
      
      <label class="block text-sm font-medium text-slate-600 dark:text-slate-300 mt-3 mb-2">Notes (optional)</label>
      <textarea id="editNotes" 
                class="w-full rounded-md border border-slate-300 px-3 py-2 text-sm min-h-[80px] focus:outline-none focus:ring-2 focus:ring-sky-200 dark:bg-slate-950 dark:border-slate-700 dark:text-slate-200" 
                placeholder="Add any additional notes here..."></textarea>

      <div class="dropdown mt-2" id="editTagDropdown">
        <div class="dropdown-btn" id="editDropdownBtn"><span class="placeholder">Select tags...</span></div>
        <div class="dropdown-list" id="editDropdownList">
          <label><input type="checkbox" value="Design" /> <span>Design</span></label>
          <label><input type="checkbox" value="Mechanical" /> <span>Mechanical</span></label>
          <label><input type="checkbox" value="Programming" /> <span>Programming</span></label>
          <label><input type="checkbox" value="Electrical" /> <span>Electrical</span></label>
          <label><input type="checkbox" value="Business" /> <span>Business</span></label>
          <label><input type="checkbox" value="Website" /> <span>Website</span></label>
          <label><input type="checkbox" value="Drive" /> <span>Drive</span></label>
        </div>
      </div>

      <div class="flex gap-2 pt-2">
        <button id="saveEdit" class="px-3 py-1 bg-sky-600 text-white rounded-md text-sm hover:bg-sky-700">Save</button>
        <button id="cancelEdit" class="px-3 py-1 border border-slate-300 rounded-md text-sm hover:bg-slate-50 dark:border-slate-700 dark:text-slate-300 dark:hover:bg-slate-800">Cancel</button>
      </div>
    </div>
  `;
  document.body.appendChild(modal);

  modal.querySelector("#editTitle").value = task.title || "";
  modal.querySelector("#editAssign").value = task.assignee || "";
  modal.querySelector("#editDue").value = task.due || "";
  
  // Populate checklist and notes
  let descModelToEdit = task.descModel;
  
  // If no descModel exists, migrate from old description
  if (!descModelToEdit && task.description) {
    descModelToEdit = parseOldDescription(task.description);
  }
  
  // Populate checklist items
  if (descModelToEdit && descModelToEdit.items) {
    populateChecklistUI(descModelToEdit.items, "editChecklistItems");
  }
  
  // Populate notes
  modal.querySelector("#editNotes").value = (descModelToEdit && descModelToEdit.notes) || "";
  
  // Setup Add Item button for edit modal
  setTimeout(() => {
    const addItemBtn = modal.querySelector("#editAddChecklistItemBtn");
    if (addItemBtn) {
      addItemBtn.onclick = () => createChecklistItemUI("", false, "editChecklistItems");
    }
  }, 0);

  let editSelectedTags = Array.isArray(task.tags) ? task.tags.slice() : [];
  const editDropdownBtn = modal.querySelector("#editDropdownBtn");
  const editDropdownList = modal.querySelector("#editDropdownList");

  function updateEditDropdownBtn() {
    editDropdownBtn.innerHTML = editSelectedTags.length ? chipsHTML(editSelectedTags) : '<span class="placeholder">Select tags...</span>';
  }

  editDropdownList.querySelectorAll("input[type=checkbox]").forEach(cb => {
    cb.checked = editSelectedTags.includes(cb.value);
    cb.addEventListener("change", () => {
      editSelectedTags = Array.from(editDropdownList.querySelectorAll("input:checked")).map(c => c.value);
      updateEditDropdownBtn();
    });
  });

  editDropdownBtn.addEventListener("click", () => {
    editDropdownList.style.display = editDropdownList.style.display === "block" ? "none" : "block";
  });

  document.addEventListener("click", e => { if (!modal.contains(e.target)) editDropdownList.style.display = "none"; });

  updateEditDropdownBtn();

  modal.querySelector("#cancelEdit").onclick = () => modal.remove();
  modal.querySelector("#saveEdit").onclick = async () => {
    const saveBtn = modal.querySelector("#saveEdit");
    const originalSaveText = saveBtn.textContent;
    
    try {
      saveBtn.disabled = true;
      saveBtn.textContent = "Saving...";
      
      task.title = (modal.querySelector("#editTitle").value || "").trim();
      task.assignee = (modal.querySelector("#editAssign").value || "Unassigned").trim() || "Unassigned";
      task.due = modal.querySelector("#editDue").value || "";
      task.tags = editSelectedTags.slice();
      
      // Get checklist items and notes
      const checklistItems = getChecklistItems("editChecklistItems");
      const notes = (modal.querySelector("#editNotes").value || "").trim();
      
      // Create new descModel
      task.descModel = createDescModel(checklistItems, notes);
      task.descHtml = generateDescHtml(task.descModel, task.id);
      task.descText = generateDescText(task.descModel);

      await saveTask(task, colId);

      showToast('success', 'Task saved!');
      modal.remove();
      renderBoard();
    } catch (err) {
      console.error("Failed to save task:", err);
      showToast('error', `Failed to save task: ${err?.message || err}`);
    } finally {
      saveBtn.disabled = false;
      saveBtn.textContent = originalSaveText;
    }
  };
}

/* Drag and drop */
function makeDraggable(taskEl) {
  taskEl.addEventListener("dragstart", e => {
    taskEl.classList.add("dragging");
    e.dataTransfer.setData("text/plain", JSON.stringify({ id: taskEl.dataset.id, from: taskEl.dataset.col }));
  });

  taskEl.addEventListener("dragend", async () => {
    taskEl.classList.remove("dragging");

    const parentCol = taskEl.closest(".task-list");
    if (!parentCol) return;

    const siblings = [...parentCol.querySelectorAll("[data-id]")];
    const batch = writeBatch(db);

    for (let i = 0; i < siblings.length; i++) {
      const id = siblings[i].dataset.id;
      batch.update(doc(db, "tasks", id), { order: i, column: parentCol.dataset.col });
    }
    await batch.commit();
  });
}

function makeDroppable(el) {
  el.addEventListener("dragover", e => {
    e.preventDefault();
    const dragging = document.querySelector(".dragging");
    if (!dragging) return;

    const afterElement = getDragAfterElement(el, e.clientY);
    if (afterElement && afterElement instanceof Node) {
      el.insertBefore(dragging, afterElement);
    } else {
      el.appendChild(dragging);
    }
  });
  el.addEventListener("dragenter", () => el.classList.add("droppable-hover"));
  el.addEventListener("dragleave", () => el.classList.remove("droppable-hover"));
  el.addEventListener("drop", async e => {
    e.preventDefault();
    el.classList.remove("droppable-hover");

    const data = e.dataTransfer.getData("text/plain");
    if (!data) return;

    const { id, from } = JSON.parse(data);
    const to = el.dataset.col;
    const taskDocRef = doc(db, "tasks", id);
    const taskSnap = await getDoc(taskDocRef);
    if (!taskSnap.exists()) return;

    const taskData = taskSnap.data();
    const updates = { column: to };
    if (to === "done" && !taskData.completedAt) {
      updates.completedAt = Date.now();
      
      // Check if task was overdue when completed
      if (taskData.due) {
        const dueDate = new Date(taskData.due + "T23:59:59");
        const now = new Date();
        updates.wasOverdueWhenCompleted = now > dueDate;
      } else {
        // No due date means not overdue
        updates.wasOverdueWhenCompleted = false;
      }
    } else if (from === "done" && to !== "done") {
      updates.completedAt = null;
      updates.wasOverdueWhenCompleted = null;
    }

    await setDoc(taskDocRef, updates, { merge: true });

    const taskEls = [...el.querySelectorAll("[data-id]")];
    const batch = writeBatch(db);
    for (let i = 0; i < taskEls.length; i++) {
      const tId = taskEls[i].dataset.id;
      batch.update(doc(db, "tasks", tId), { order: i, column: to });
    }
    await batch.commit();

    await renderBoard();
  });
}

function getDragAfterElement(container, y) {
  const draggableElements = [...container.querySelectorAll(".task-card:not(.dragging)")];
  return draggableElements.reduce((closest, child) => {
    const box = child.getBoundingClientRect();
    const offset = y - box.top - box.height / 2;
    if (offset < 0 && offset > closest.offset) {
      return { offset, element: child };
    } else {
      return closest;
    }
  }, { offset: Number.NEGATIVE_INFINITY }).element;
}

/* Checklist UI Management */
function createChecklistItemUI(text = "", checked = false, containerId) {
  const container = document.getElementById(containerId);
  if (!container) return;
  
  const itemDiv = document.createElement("div");
  itemDiv.className = "flex items-center gap-2";
  itemDiv.innerHTML = `
    <input type="checkbox" class="w-4 h-4 rounded border-slate-300 dark:border-slate-600" ${checked ? "checked" : ""} />
    <input type="text" 
           class="flex-1 rounded-md border border-slate-300 px-2 py-1 text-sm focus:outline-none focus:ring-2 focus:ring-sky-200 dark:bg-slate-950 dark:border-slate-700 dark:text-slate-200" 
           placeholder="Item text..." 
           value="${escHtml(text)}" />
    <button class="delete-item text-red-600 hover:text-red-700 dark:text-red-400 px-2 py-1 text-sm">
      <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />
      </svg>
    </button>
  `;
  
  // Delete button handler
  itemDiv.querySelector(".delete-item").onclick = () => {
    itemDiv.remove();
  };
  
  container.appendChild(itemDiv);
  return itemDiv;
}

function getChecklistItems(containerId) {
  const container = document.getElementById(containerId);
  if (!container) return [];
  
  const items = [];
  container.querySelectorAll(":scope > div").forEach(itemDiv => {
    const checkbox = itemDiv.querySelector('input[type="checkbox"]');
    const textInput = itemDiv.querySelector('input[type="text"]');
    if (checkbox && textInput) {
      const text = textInput.value.trim();
      if (text) { // Only include non-empty items
        items.push({
          text: text,
          checked: checkbox.checked
        });
      }
    }
  });
  
  return items;
}

function clearChecklistUI(containerId) {
  const container = document.getElementById(containerId);
  if (container) container.innerHTML = "";
}

function populateChecklistUI(items, containerId) {
  clearChecklistUI(containerId);
  if (items && items.length > 0) {
    items.forEach(item => {
      createChecklistItemUI(item.text || "", item.checked || false, containerId);
    });
  }
}

/* Add Task */
addBtn.onclick = async () => {
  const title = (document.getElementById("newTitle").value || "").trim();
  if (!title) return;

  const assign = document.getElementById("newAssign").value || "Unassigned";
  const due = document.getElementById("newDue").value || "";
  
  // Get checklist items and notes
  const checklistItems = getChecklistItems("checklistItems");
  const notes = (document.getElementById("newNotes").value || "").trim();
  
  addBtn.disabled = true;
  const originalAddLabel = addBtn.textContent;
  addBtn.textContent = "Adding...";

  try {
    const snapshot = await getDocs(collection(db, "tasks"));
    const count = snapshot.size;
    
    // Create descModel
    const descModel = createDescModel(checklistItems, notes);
    
    const task = {
      title,
      assignee: assign,
      due,
      descModel: descModel,
      descHtml: generateDescHtml(descModel, "temp"), // ID will be assigned by Firestore
      descText: generateDescText(descModel),
      tags: selectedTags.slice(),
      column: "backlog",
      order: count
    };

    const docRef = await addDoc(collection(db, "tasks"), task);
    
    // Update descHtml with actual ID
    if (checklistItems.length > 0) {
      await setDoc(doc(db, "tasks", docRef.id), {
        descHtml: generateDescHtml(descModel, docRef.id)
      }, { merge: true });
    }

    // Clear form
    document.getElementById("newTitle").value = "";
    document.getElementById("newAssign").value = "";
    document.getElementById("newDue").value = "";
    document.getElementById("newNotes").value = "";
    clearChecklistUI("checklistItems");
    selectedTags = [];
    document.querySelectorAll("#dropdownList input[type=checkbox]").forEach(cb => cb.checked = false);
    updateDropdownBtn();

    await renderBoard();

    showToast('success', 'Task added successfully!');
  } catch (err) {
    console.error("Failed to add task:", err);
    showToast('error', `Failed to add task: ${err?.message || err}`);
  } finally {
    addBtn.disabled = false;
    addBtn.textContent = originalAddLabel || "Add Task";
  }
};

/* Drawer (Trash & Archive) */
async function renderDrawer() {
  const snapshot = await getDocs(collection(db, "tasks"));
  const trashTasks = [];
  const archiveTasks = [];

  snapshot.forEach(docSnap => {
    const t = { id: docSnap.id, ...docSnap.data() };
    if (t.deleted) trashTasks.push(t);
    if (t.archived) archiveTasks.push(t);
  });

  // Trash
  const trashList = document.getElementById("trashList");
  trashList.innerHTML = trashTasks
    .sort((a, b) => (b.deletedAt || 0) - (a.deletedAt || 0))
    .map(t => `
      <div class="p-3 border border-slate-200 dark:border-slate-700 rounded-lg bg-white dark:bg-slate-900">
        <div class="font-medium text-slate-800 dark:text-slate-200">${t.title}</div>
        <div class="text-xs text-slate-500 dark:text-slate-400">${t.assignee || "Unassigned"} • ${formatDueDate(t.due || "")}</div>
        <div class="text-xs text-slate-400 mt-1">Deleted by ${t.deletedBy || "Unknown"}</div>
        <div class="flex gap-2 mt-2">
          <button data-id="${t.id}" class="restore-btn text-xs px-2 py-1 bg-sky-600 text-white rounded-md hover:bg-sky-700">Restore</button>
          <button data-id="${t.id}" class="permadelete-btn text-xs px-2 py-1 bg-red-600 text-white rounded-md hover:bg-red-700">Permanently Delete</button>
        </div>
      </div>
    `).join("") || '<div class="text-sm text-slate-500 dark:text-slate-400">No items in trash</div>';

  // Archive
  const archiveList = document.getElementById("archiveList");
  archiveList.innerHTML = archiveTasks
    .sort((a, b) => (b.archivedAt || 0) - (a.archivedAt || 0))
    .map(t => `
      <div class="p-3 border border-slate-200 dark:border-slate-700 rounded-lg bg-white dark:bg-slate-900">
        <div class="font-medium text-slate-800 dark:text-slate-200">${t.title}</div>
        <div class="text-xs text-slate-500 dark:text-slate-400">${t.assignee || "Unassigned"}</div>
        <div class="text-xs text-slate-400 mt-1">Completed: ${t.completedAt ? new Date(t.completedAt).toLocaleDateString() : "N/A"}</div>
        <div class="text-xs text-slate-400">Archived: ${t.archivedAt ? new Date(t.archivedAt).toLocaleDateString() : "N/A"}</div>
        <div class="flex gap-2 mt-2">
          <button data-id="${t.id}" class="unarchive-btn text-xs px-2 py-1 bg-sky-600 text-white rounded-md hover:bg-sky-700">Unarchive</button>
          <button data-id="${t.id}" class="permadelete-btn text-xs px-2 py-1 bg-red-600 text-white rounded-md hover:bg-red-700">Permanently Delete</button>
        </div>
      </div>
    `).join("") || '<div class="text-sm text-slate-500 dark:text-slate-400">No items in archive</div>';

  // Wire actions
  trashList.querySelectorAll(".restore-btn").forEach(btn => {
    btn.onclick = async () => {
      const id = btn.getAttribute("data-id");
      await setDoc(doc(db, "tasks", id), { deleted: false, deletedAt: null, deletedBy: null }, { merge: true });
      await renderBoard(); await renderDrawer();
    };
  });
  [...trashList.querySelectorAll(".permadelete-btn"), ...archiveList.querySelectorAll(".permadelete-btn")].forEach(btn => {
    btn.onclick = async () => {
      const id = btn.getAttribute("data-id");
      if (!confirm("Permanently delete this task? This cannot be undone.")) return;
      await deleteTaskFirestore(id);
      await renderDrawer();
    };
  });
  archiveList.querySelectorAll(".unarchive-btn").forEach(btn => {
    btn.onclick = async () => {
      const id = btn.getAttribute("data-id");
      await setDoc(doc(db, "tasks", id), { archived: false, archivedAt: null, column: "backlog" }, { merge: true });
      await renderBoard(); await renderDrawer();
    };
  });
}

/* Filter */
// Text search filter - triggers on input
filterInput.oninput = () => { renderBoard(); };

// Note: Subteam filter event handling is now done in the custom dropdown code above
// The subteam filter uses a custom dropdown with radio buttons (single-select)
// When a subteam is selected, only tasks with that subteam tag are shown
// When "All Subteams" is selected (empty value), all tasks are shown

    /* Chips util */
    function chipsHTML(tags) {
      return (tags || []).map(t => `<span class="tag-chip" data-tag="${escHtml(String(t).toLowerCase())}">${escHtml(String(t))}</span>`).join("");
    }
    function getCurrentUserName() {
      return localStorage.getItem('trident.fullname') || 'Anonymous';
    }

    /* Column canonicalization */
    function canonicalizeColumn(raw) {
      const s = String(raw || '').trim().toLowerCase();
      if (!s) return 'backlog';
      // remove spaces/dashes for mapping
      const compact = s.replace(/[\s-]+/g, '');
      switch (compact) {
        case 'backlog': return 'backlog';
        case 'todo':
        case 'todolist':
        case 'to':
        case 'todo:': return 'todo';
        case 'inprogress':
        case 'inprog':
        case 'progress':
        case 'working':
        case 'doing': return 'inprogress';
        case 'done':
        case 'complete':
        case 'completed': return 'done';
        default: return s; // fallback (will render if added to order dynamically)
      }
    }

    /* Override loadTasks to normalize columns */
    const _originalLoadTasks = loadTasks;
    loadTasks = async function() {
      const snapshot = await getDocs(collection(db, "tasks"));
      console.log('[TaskBoard] Snapshot size:', snapshot.size);
      const data = {
        columns: {
          backlog: { title: "Backlog", tasks: [] },
          todo: { title: "To Do", tasks: [] },
          inprogress: { title: "In Progress", tasks: [] },
          done: { title: "Done", tasks: [] }
        },
        order: ["backlog", "todo", "inprogress", "done"]
      };
      
      // Collect all tasks for notifications
      const allTasks = [];
      
      snapshot.forEach(docSnap => {
        const t = docSnap.data();
        const taskWithId = { id: docSnap.id, ...t };
        
        // Add to allTasks array (including deleted/archived for complete view)
        allTasks.push(taskWithId);
        
        if (t.deleted || t.archived) return;
        const normalized = canonicalizeColumn(t.column || 'backlog');
        console.log('[TaskBoard] Doc', docSnap.id, 'raw column:', t.column, 'normalized:', normalized);
        (data.columns[normalized] ??= { title: normalized, tasks: [] })
          .tasks.push({ ...taskWithId, column: normalized });
      });
      
      // Expose all tasks globally for notification system
      window.currentTasks = allTasks;
      
      await checkAutoArchive(data);
      return data;
    };

    /* Optional one-time migration to fix column values in Firestore */
    async function fixColumns() {
      const snapshot = await getDocs(collection(db, "tasks"));
      const batch = writeBatch(db);
      let changed = 0;
      snapshot.forEach(docSnap => {
        const t = docSnap.data();
        const canonical = canonicalizeColumn(t.column || 'backlog');
        if (canonical !== t.column) {
          batch.update(doc(db, "tasks", docSnap.id), { column: canonical });
          changed++;
        }
      });
      if (changed) {
        await batch.commit();
        console.log(`[TaskBoard] Column migration updated ${changed} task(s).`);
      } else {
        console.log('[TaskBoard] Column migration: nothing to change.');
      }
    }
    
    /* Migrate old description format to new descModel */
    async function migrateDescriptions() {
      const snapshot = await getDocs(collection(db, "tasks"));
      const batch = writeBatch(db);
      let migrated = 0;
      
      snapshot.forEach(docSnap => {
        const t = docSnap.data();
        const taskId = docSnap.id;
        
        // Skip if already has descModel
        if (t.descModel) return;
        
        // Skip if no description
        if (!t.description) return;
        
        // Parse old description into new model
        const descModel = parseOldDescription(t.description);
        
        // Only migrate if we found something to migrate
        if (descModel.items.length > 0 || descModel.notes) {
          batch.update(doc(db, "tasks", taskId), {
            descModel: descModel,
            descHtml: generateDescHtml(descModel, taskId),
            descText: generateDescText(descModel)
          });
          migrated++;
        }
      });
      
      if (migrated > 0) {
        await batch.commit();
        console.log(`[TaskBoard] Description migration updated ${migrated} task(s).`);
      } else {
        console.log('[TaskBoard] Description migration: nothing to migrate.');
      }
    }

    /* Enhance renderBoard to show empty state per column */
    const _renderBoardOriginal = renderBoard;
    renderBoard = async function() {
      await _renderBoardOriginal();
      document.querySelectorAll(".task-list").forEach(list => {
        if (!list.children.length) {
          list.innerHTML = `<div class="p-3 text-xs rounded-md border border-slate-200 dark:border-slate-700 bg-white dark:bg-slate-900 text-slate-500 dark:text-slate-400">
            No tasks
          </div>`;
        }
      });
    };

    /* Bootstrap */
    async function bootstrap() {
      try {
        // Uncomment next line ONCE if you need to normalize existing column values:
        // await fixColumns();
        
        // Run description migration (safe to run multiple times)
        await migrateDescriptions();

        await renderBoard();

        // Ensure tag dropdown starts hidden
        const dropdownList = document.getElementById("dropdownList");
        if (dropdownList) dropdownList.style.display = "none";
        
        // Setup Add Item buttons for checklist UI
        const addItemBtn = document.getElementById("addChecklistItemBtn");
        if (addItemBtn) {
          addItemBtn.addEventListener("click", () => {
            createChecklistItemUI("", false, "checklistItems");
          });
        }

        console.log('[TaskBoard] Bootstrap complete');
        
        // Initialize notification system after tasks are loaded
        if (window.Notifications && typeof window.Notifications.initNotifications === 'function') {
          // Wait a bit to ensure all scripts are loaded
          setTimeout(() => {
            window.Notifications.initNotifications();
            console.log('[TaskBoard] Notifications initialized');
          }, 1000);
        }
      } catch (e) {
        console.error('Bootstrap failed:', e);
        const board = document.getElementById("board");
        if (board) {
          board.innerHTML = `<div class="col-span-4 p-6 border border-red-200 bg-red-50 rounded-xl text-red-700 text-sm">
            Failed to load tasks: ${e.message || e}
          </div>`;
        }
        if (typeof showToast === 'function') {
          showToast('error', `Load failed: ${e.message || e}`);
        }
      }
    }

    document.addEventListener('DOMContentLoaded', bootstrap);
    if (document.readyState === 'interactive' || document.readyState === 'complete') {
      // DOM already ready if script injected late
      bootstrap();
    }


</script>

<!-- Old Formatting Toolbar Script - No longer needed -->
<script>
(function() {
  'use strict';
  // This script has been replaced by the new Checklist + Notes system
  // Keeping the script tag structure for reference but functionality is removed
  
  /* ========== WYSIWYG Formatting Toolbar Functionality ========== */
  
  // Sticky format state per editor
  const stickyFormats = new Map();
  
  // Setup formatting toolbar for a contenteditable element
  function setupFormattingToolbar(toolbarId, editorId) {
    const toolbar = document.getElementById(toolbarId);
    const editor = document.getElementById(editorId);
    if (!toolbar || !editor) {
      console.warn('Toolbar or editor not found:', toolbarId, editorId);
      return;
    }
    
    console.log('Setting up WYSIWYG formatting toolbar:', toolbarId, 'for', editorId);
    
    // Initialize sticky formats for this editor
    if (!stickyFormats.has(editorId)) {
      stickyFormats.set(editorId, {
        bold: false,
        italic: false,
        underline: false,
        highlight: false,
        color: null,
        size: null
      });
    }
    
    // Handle toolbar button clicks
    toolbar.addEventListener('click', (e) => {
      const btn = e.target.closest('.format-btn');
      if (!btn) return;
      
      e.preventDefault();
      const format = btn.getAttribute('data-format');
      
      // Toggle dropdowns
      if (format === 'color' || format === 'size') {
        e.stopPropagation();
        const dropdown = btn.closest('.format-dropdown');
        const menu = dropdown.querySelector('.format-dropdown-menu');
        const wasOpen = menu.classList.contains('show');
        
        // Close all other dropdowns
        toolbar.querySelectorAll('.format-dropdown-menu').forEach(m => m.classList.remove('show'));
        
        if (!wasOpen) {
          menu.classList.add('show');
        }
        return;
      }
      
      // Clear all sticky formats
      if (format === 'clear') {
        clearStickyFormats(editorId, toolbar);
        return;
      }
      
      // Remove format from selection
      if (format === 'remove') {
        removeFormatFromSelection(editor);
        return;
      }
      
      // Apply formatting (selection-aware with toggle)
      if (['bold', 'italic', 'underline', 'highlight'].includes(format)) {
        applyFormatWithToggle(editor, editorId, format, btn, toolbar);
      }
    });
    
    // Handle color selection
    const colorMenus = toolbar.querySelectorAll('[id$="ColorMenu"]');
    colorMenus.forEach(menu => {
      menu.addEventListener('click', (e) => {
        const item = e.target.closest('.format-dropdown-item');
        if (!item) return;
        const color = item.getAttribute('data-color');
        if (color) {
          const sticky = stickyFormats.get(editorId);
          if (color === 'default') {
            sticky.color = null;
          } else {
            sticky.color = color;
          }
          updateStickyButtonState(toolbar, 'color', sticky.color !== null);
          menu.classList.remove('show');
        }
      });
    });
    
    // Handle size selection
    const sizeMenus = toolbar.querySelectorAll('[id$="SizeMenu"]');
    sizeMenus.forEach(menu => {
      menu.addEventListener('click', (e) => {
        const item = e.target.closest('.format-dropdown-item');
        if (!item) return;
        const size = item.getAttribute('data-size');
        if (size) {
          const sticky = stickyFormats.get(editorId);
          if (size === 'normal') {
            sticky.size = null;
          } else {
            sticky.size = size;
          }
          updateStickyButtonState(toolbar, 'size', sticky.size !== null);
          menu.classList.remove('show');
        }
      });
    });
    
    // Close dropdowns when clicking outside
    document.addEventListener('click', (e) => {
      if (!toolbar.contains(e.target)) {
        toolbar.querySelectorAll('.format-dropdown-menu').forEach(m => m.classList.remove('show'));
      }
    });
    
    // Setup live checklist conversion
    setupChecklistConversion(editor);
    
    // Setup paste sanitization
    setupPasteSanitization(editor, editorId);
    
    // Setup input handler for sticky formatting
    setupStickyFormatting(editor, editorId);
  }
  
  // Apply format with toggle support (selection-aware)
  function applyFormatWithToggle(editor, editorId, format, btn, toolbar) {
    editor.focus();
    const selection = window.getSelection();
    const sticky = stickyFormats.get(editorId);
    
    // Check if there's a selection
    if (selection && !selection.isCollapsed && selection.rangeCount > 0) {
      // Apply/remove format to/from selection
      const range = selection.getRangeAt(0);
      
      // Check if the selection already has this format
      const hasFormat = selectionHasFormat(range, format);
      
      if (hasFormat) {
        // Remove format from selection
        removeFormatFromRange(range, format);
        // Also turn off sticky state
        sticky[format] = false;
        updateStickyButtonState(toolbar, format, false);
      } else {
        // Apply format to selection
        applyFormatToRange(range, format);
        // Turn on sticky state so new typing continues with this format
        sticky[format] = true;
        updateStickyButtonState(toolbar, format, true);
      }
      
      return;
    }
    
    // No selection: toggle sticky format
    sticky[format] = !sticky[format];
    updateStickyButtonState(toolbar, format, sticky[format]);
  }
  
  // Check if a range has a specific format
  function selectionHasFormat(range, format) {
    const container = range.commonAncestorContainer;
    const element = container.nodeType === Node.TEXT_NODE ? container.parentElement : container;
    
    // Check for format in parent hierarchy
    let current = element;
    while (current && current.contentEditable !== 'true') {
      if (format === 'bold' && current.tagName === 'B') return true;
      if (format === 'italic' && current.tagName === 'I') return true;
      if (format === 'underline' && (current.tagName === 'U' || current.classList.contains('desc-underline'))) return true;
      if (format === 'highlight' && current.classList.contains('desc-hl')) return true;
      current = current.parentElement;
    }
    return false;
  }
  
  // Apply format to a range
  function applyFormatToRange(range, format) {
    const fragment = range.extractContents();
    const wrapper = createFormatWrapper(format);
    wrapper.appendChild(fragment);
    range.insertNode(wrapper);
    
    // Restore selection
    const selection = window.getSelection();
    selection.removeAllRanges();
    const newRange = document.createRange();
    newRange.selectNodeContents(wrapper);
    selection.addRange(newRange);
  }
  
  // Remove format from a range
  function removeFormatFromRange(range, format) {
    const fragment = range.extractContents();
    
    // Remove format tags from fragment
    const temp = document.createElement('div');
    temp.appendChild(fragment);
    
    removeFormatFromElement(temp, format);
    
    // Reinsert cleaned content
    while (temp.firstChild) {
      range.insertNode(temp.lastChild);
    }
  }
  
  // Create wrapper element for a format
  function createFormatWrapper(format) {
    switch(format) {
      case 'bold':
        return document.createElement('b');
      case 'italic':
        return document.createElement('i');
      case 'underline':
        const u = document.createElement('u');
        u.className = 'desc-underline';
        return u;
      case 'highlight':
        const span = document.createElement('span');
        span.className = 'desc-hl';
        return span;
      default:
        return document.createElement('span');
    }
  }
  
  // Remove specific format from an element and its children
  function removeFormatFromElement(element, format) {
    const nodesToRemove = [];
    
    // Find all nodes with the format
    const walker = document.createTreeWalker(element, NodeFilter.SHOW_ELEMENT);
    let node = walker.currentNode;
    
    while (node) {
      let shouldRemove = false;
      
      if (format === 'bold' && node.tagName === 'B') shouldRemove = true;
      if (format === 'italic' && node.tagName === 'I') shouldRemove = true;
      if (format === 'underline' && (node.tagName === 'U' || node.classList.contains('desc-underline'))) shouldRemove = true;
      if (format === 'highlight' && node.classList.contains('desc-hl')) shouldRemove = true;
      
      if (shouldRemove) {
        nodesToRemove.push(node);
      }
      
      node = walker.nextNode();
    }
    
    // Remove format nodes by replacing with their content
    nodesToRemove.forEach(node => {
      while (node.firstChild) {
        node.parentNode.insertBefore(node.firstChild, node);
      }
      node.parentNode.removeChild(node);
    });
  }
  
  // Update button visual state
  function updateStickyButtonState(toolbar, format, active) {
    const btn = toolbar.querySelector(`[data-format="${format}"]`);
    if (btn) {
      if (active) {
        btn.classList.add('sticky-active');
      } else {
        btn.classList.remove('sticky-active');
      }
    }
  }
  
  // Clear all sticky formats
  function clearStickyFormats(editorId, toolbar) {
    const sticky = stickyFormats.get(editorId);
    sticky.bold = false;
    sticky.italic = false;
    sticky.underline = false;
    sticky.highlight = false;
    sticky.color = null;
    sticky.size = null;
    
    // Update all button states
    ['bold', 'italic', 'underline', 'highlight', 'color', 'size'].forEach(format => {
      updateStickyButtonState(toolbar, format, false);
    });
  }
  
  // Remove format from selected text
  function removeFormatFromSelection(editor) {
    editor.focus();
    const selection = window.getSelection();
    
    if (!selection.rangeCount || selection.isCollapsed) {
      if (typeof showToast === 'function') {
        showToast('info', 'Please select text to remove formatting');
      }
      return;
    }
    
    const range = selection.getRangeAt(0);
    const fragment = range.extractContents();
    
    // Strip all formatting tags
    const textContent = fragment.textContent;
    const textNode = document.createTextNode(textContent);
    range.insertNode(textNode);
    
    // Restore selection
    selection.removeAllRanges();
    const newRange = document.createRange();
    newRange.setStartAfter(textNode);
    newRange.collapse(true);
    selection.addRange(newRange);
  }
  
  // Setup sticky formatting on input
  function setupStickyFormatting(editor, editorId) {
    // Track if we're currently applying formats to prevent recursion
    let isApplyingFormat = false;
    
    editor.addEventListener('beforeinput', (e) => {
      if (isApplyingFormat) return;
      
      const sticky = stickyFormats.get(editorId);
      if (!sticky) return;
      
      // Check if any sticky formats are active
      const hasActiveFormats = sticky.bold || sticky.italic || sticky.underline || 
                                sticky.highlight || sticky.color || sticky.size;
      
      if (!hasActiveFormats) return;
      
      // Only handle text insertion
      if (e.inputType !== 'insertText' && e.inputType !== 'insertFromPaste') return;
      
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      
      const range = selection.getRangeAt(0);
      const node = range.startContainer;
      
      // Don't apply to checkbox labels
      const parent = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
      if (parent && (parent.tagName === 'LABEL' || parent.closest('label'))) return;
      
      // Check current formatting context
      const currentFormats = getCurrentFormats(node);
      
      // Check if current formats match sticky formats
      const formatsMatch = matchesAllStickyFormats(currentFormats, sticky);
      
      // If formats match and no sticky formats are active, let default behavior
      if (formatsMatch && !hasActiveFormats) return;
      
      // Otherwise, we need to apply sticky formats explicitly
      e.preventDefault();
      isApplyingFormat = true;
      
      // Insert text with correct sticky formats
      const textNode = document.createTextNode(e.data);
      let wrapper = textNode;
      
      // Only wrap if we have active sticky formats
      if (hasActiveFormats) {
        wrapper = wrapWithStickyFormats(textNode, sticky);
      }
      
      range.deleteContents();
      range.insertNode(wrapper);
      
      // Move cursor after inserted text
      const newRange = document.createRange();
      newRange.setStartAfter(hasActiveFormats ? wrapper : textNode);
      newRange.collapse(true);
      selection.removeAllRanges();
      selection.addRange(newRange);
      
      isApplyingFormat = false;

    });
  }
  
  // Helper to get current formats at cursor position
  function getCurrentFormats(node) {
    const formats = {
      bold: false,
      italic: false,
      underline: false,
      highlight: false,
      color: null,
      size: null
    };
    
    let current = node.nodeType === Node.TEXT_NODE ? node.parentElement : node;
    while (current && current.contentEditable !== 'true') {
      if (current.tagName === 'B') formats.bold = true;
      if (current.tagName === 'I') formats.italic = true;
      if (current.tagName === 'U' || current.classList.contains('desc-underline')) formats.underline = true;
      if (current.classList.contains('desc-hl')) formats.highlight = true;
      
      // Check for color classes
      const colorMatch = Array.from(current.classList).find(cls => cls.startsWith('desc-color-'));
      if (colorMatch) formats.color = colorMatch.replace('desc-color-', '');
      
      // Check for size classes
      const sizeMatch = Array.from(current.classList).find(cls => cls.startsWith('desc-size-'));
      if (sizeMatch) formats.size = sizeMatch.replace('desc-size-', '');
      
      current = current.parentElement;
    }
    
    return formats;
  }
  
  // Helper to check if current formats match sticky formats
  function matchesAllStickyFormats(current, sticky) {
    return current.bold === sticky.bold &&
           current.italic === sticky.italic &&
           current.underline === sticky.underline &&
           current.highlight === sticky.highlight &&
           current.color === sticky.color &&
           current.size === sticky.size;
  }
  
  // Helper to wrap text node with sticky formats
  function wrapWithStickyFormats(textNode, sticky) {
    let wrapper = textNode;
    
    if (sticky.size) {
      const span = document.createElement('span');
      span.className = `desc-size-${sticky.size}`;
      span.appendChild(wrapper);
      wrapper = span;
    }
    
    if (sticky.color) {
      const span = document.createElement('span');
      span.className = `desc-color-${sticky.color}`;
      span.appendChild(wrapper);
      wrapper = span;
    }
    
    if (sticky.highlight) {
      const span = document.createElement('span');
      span.className = 'desc-hl';
      span.appendChild(wrapper);
      wrapper = span;
    }
    
    if (sticky.underline) {
      const u = document.createElement('u');
      u.className = 'desc-underline';
      u.appendChild(wrapper);
      wrapper = u;
    }
    
    if (sticky.italic) {
      const i = document.createElement('i');
      i.appendChild(wrapper);
      wrapper = i;
    }
    
    if (sticky.bold) {
      const b = document.createElement('b');
      b.appendChild(wrapper);
      wrapper = b;
    }
    
    return wrapper;
  }

  
  // Setup live checklist conversion
  function setupChecklistConversion(editor) {
    // Handle automatic checklist pattern conversion
    editor.addEventListener('input', (e) => {
      const selection = window.getSelection();
      if (!selection.rangeCount) return;
      
      const range = selection.getRangeAt(0);
      const node = range.startContainer;
      
      // Get the text content before cursor
      if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent;
        const offset = range.startOffset;
        const beforeCursor = text.substring(0, offset);
        
        // Check for checklist pattern at start of line
        const checkboxMatch = beforeCursor.match(/^-\s*\[([ xX])\]\s$/);
        if (checkboxMatch) {
          const checked = checkboxMatch[1].toLowerCase() === 'x';
          
          // Remove the pattern text
          const textNode = node;
          textNode.textContent = text.substring(offset);
          
          // Create and insert checkbox
          const label = createChecklistLabel(checked);
          
          if (textNode.parentNode) {
            textNode.parentNode.insertBefore(label, textNode);
            
            // Remove empty text node if it exists
            if (!textNode.textContent.trim()) {
              textNode.remove();
            }
            
            // Place cursor in the span
            const span = label.querySelector('span');
            const newRange = document.createRange();
            newRange.setStart(span, 0);
            newRange.collapse(true);
            selection.removeAllRanges();
            selection.addRange(newRange);
          }
        }
      }
    });
    
    // Handle Enter key to create new checklist items or line breaks
    editor.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        const selection = window.getSelection();
        if (!selection.rangeCount) return;
        
        const range = selection.getRangeAt(0);
        const node = range.startContainer;
        
        // Shift+Enter: insert soft break (BR)
        if (e.shiftKey) {
          e.preventDefault();
          const br = document.createElement('br');
          range.deleteContents();
          range.insertNode(br);
          range.setStartAfter(br);
          range.collapse(true);
          selection.removeAllRanges();
          selection.addRange(range);
          return;
        }
        
        // Check if we're inside a checklist label
        const label = node.nodeType === Node.TEXT_NODE 
          ? node.parentElement?.closest('label')
          : node.closest('label');
        
        if (label && label.querySelector('.desc-checkbox')) {
          e.preventDefault();
          
          // Get the checkbox state
          const checkbox = label.querySelector('.desc-checkbox');
          const wasChecked = checkbox.checked;
          
          // Create new checklist item (unchecked by default)
          const newLabel = createChecklistLabel(false);
          
          // Insert after current label
          label.parentNode.insertBefore(newLabel, label.nextSibling);
          
          // Focus on the new label's span
          const newSpan = newLabel.querySelector('span');
          const newRange = document.createRange();
          newRange.setStart(newSpan, 0);
          newRange.collapse(true);
          selection.removeAllRanges();
          selection.addRange(newRange);
        } else {
          // Regular Enter: create new line (new div)
          e.preventDefault();
          
          // Split the current line at cursor
          const currentNode = range.startContainer;
          const currentElement = currentNode.nodeType === Node.TEXT_NODE 
            ? currentNode.parentElement 
            : currentNode;
          
          // Extract content after cursor
          const afterRange = range.cloneRange();
          afterRange.selectNodeContents(currentElement);
          afterRange.setStart(range.endContainer, range.endOffset);
          const afterContent = afterRange.extractContents();
          
          // Create new div with the after content
          const newDiv = document.createElement('div');
          if (afterContent.textContent.trim()) {
            newDiv.appendChild(afterContent);
          } else {
            newDiv.innerHTML = '<br>'; // Empty line
          }
          
          // Insert the new div after current element
          if (currentElement.nextSibling) {
            currentElement.parentNode.insertBefore(newDiv, currentElement.nextSibling);
          } else {
            currentElement.parentNode.appendChild(newDiv);
          }
          
          // Move cursor to start of new div
          const newRange = document.createRange();
          newRange.setStart(newDiv, 0);
          newRange.collapse(true);
          selection.removeAllRanges();
          selection.addRange(newRange);
        }
      }
    });
    
    // Handle checkbox clicks in editor
    editor.addEventListener('change', (e) => {
      if (e.target.type === 'checkbox' && e.target.classList.contains('desc-checkbox')) {
        console.log('Checkbox toggled in editor');
      }
    }, true);
  }
  
  // Helper to create checklist label element
  function createChecklistLabel(checked = false) {
    const label = document.createElement('label');
    label.style.display = 'flex';
    label.style.alignItems = 'start';
    label.style.gap = '0.5rem';
    label.style.padding = '0.125rem 0';
    label.style.userSelect = 'none';
    
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.checked = checked;
    checkbox.className = 'desc-checkbox';
    checkbox.style.marginTop = '0.125rem';
    checkbox.style.flexShrink = '0';
    checkbox.style.cursor = 'pointer';
    
    const span = document.createElement('span');
    span.contentEditable = 'true';
    span.textContent = '\u200B'; // Zero-width space to allow typing
    span.style.cursor = 'text';
    span.style.userSelect = 'text';
    
    // Prevent label click from affecting checkbox when clicking on text
    label.addEventListener('mousedown', (e) => {
      // Only toggle checkbox if clicking directly on the checkbox itself
      if (e.target === checkbox) {
        // Let default behavior happen
        return;
      }
      // Prevent label from toggling checkbox when clicking on text
      e.preventDefault();
      
      // If clicking on text span, focus it to allow text editing
      if (e.target === span || span.contains(e.target)) {
        span.focus();
        // Try to place cursor at click position
        const range = document.caretRangeFromPoint(e.clientX, e.clientY);
        if (range) {
          const selection = window.getSelection();
          selection.removeAllRanges();
          selection.addRange(range);
        }
      }
    });
    
    // Make checkbox independently clickable
    checkbox.addEventListener('mousedown', (e) => {
      e.stopPropagation();
      // Let default checkbox behavior happen
    });
    
    label.appendChild(checkbox);
    label.appendChild(span);
    
    return label;
  }
  
  // Setup paste sanitization
  function setupPasteSanitization(editor, editorId) {
    editor.addEventListener('paste', (e) => {
      e.preventDefault();
      
      // Get pasted data
      const text = e.clipboardData.getData('text/plain');
      const html = e.clipboardData.getData('text/html');
      
      let content = '';
      if (html) {
        // Sanitize HTML paste
        content = sanitizePastedHTML(html);
      } else if (text) {
        // Plain text paste - escape HTML
        content = text.replace(/&/g, '&amp;')
                     .replace(/</g, '&lt;')
                     .replace(/>/g, '&gt;')
                     .replace(/\n/g, '<br>');
      }
      
      // Apply active sticky formats to pasted content
      const sticky = stickyFormats.get(editorId);
      if (sticky) {
        content = applyStickyFormatsToPaste(content, sticky);
      }
      
      document.execCommand('insertHTML', false, content);
    });
  }
  
  // Apply sticky formats to pasted content
  function applyStickyFormatsToPaste(html, sticky) {
    if (!sticky) return html;
    
    let result = html;
    
    if (sticky.bold) {
      result = `<b>${result}</b>`;
    }
    if (sticky.italic) {
      result = `<i>${result}</i>`;
    }
    if (sticky.underline) {
      result = `<u class="desc-underline">${result}</u>`;
    }
    if (sticky.highlight) {
      result = `<span class="desc-hl">${result}</span>`;
    }
    if (sticky.color) {
      result = `<span class="desc-color-${sticky.color}">${result}</span>`;
    }
    if (sticky.size) {
      result = `<span class="desc-size-${sticky.size}">${result}</span>`;
    }
    
    return result;
  }
  
  // Sanitize pasted HTML to only allow whitelisted tags and classes
  function sanitizePastedHTML(html) {
    const temp = document.createElement('div');
    temp.innerHTML = html;
    
    const allowedTags = ['B', 'I', 'U', 'SPAN', 'BR'];
    const allowedClasses = [
      'desc-hl', 'desc-color-red', 'desc-color-orange', 'desc-color-yellow',
      'desc-color-green', 'desc-color-blue', 'desc-color-purple', 'desc-color-slate',
      'desc-underline', 'desc-size-xs', 'desc-size-sm', 'desc-size-base', 'desc-size-lg'
    ];
    
    function sanitizeNode(node) {
      if (node.nodeType === Node.TEXT_NODE) {
        return node.textContent;
      }
      
      if (node.nodeType === Node.ELEMENT_NODE) {
        const tagName = node.tagName.toUpperCase();
        
        // If tag not allowed, just return its text content
        if (!allowedTags.includes(tagName)) {
          return Array.from(node.childNodes).map(sanitizeNode).join('');
        }
        
        // Filter classes to only allowed ones
        const classList = Array.from(node.classList || []).filter(cls => allowedClasses.includes(cls));
        const classAttr = classList.length > 0 ? ` class="${classList.join(' ')}"` : '';
        
        // Recursively sanitize children
        const content = Array.from(node.childNodes).map(sanitizeNode).join('');
        
        return `<${tagName.toLowerCase()}${classAttr}>${content}</${tagName.toLowerCase()}>`;
      }
      
      return '';
    }
    
    return Array.from(temp.childNodes).map(sanitizeNode).join('');
  }
  
  // Add keyboard shortcuts for formatting
  function addKeyboardShortcuts(editor) {
    // Find the toolbar associated with this editor
    const editorId = editor.id;
    let toolbar = null;
    let toolbarId = null;
    
    if (editorId === 'newDescription') {
      toolbarId = 'newDescToolbar';
    } else if (editorId === 'editDescription') {
      toolbarId = 'editDescToolbar';
    }
    
    if (toolbarId) {
      toolbar = document.getElementById(toolbarId);
    }
    
    editor.addEventListener('keydown', (e) => {
      // Check for Ctrl/Cmd key combinations
      if (e.ctrlKey || e.metaKey) {
        let format = null;
        
        // Check for Shift modifier
        if (e.shiftKey) {
          if (e.key.toLowerCase() === 'h') {
            format = 'highlight';
          } else if (e.key === '0') {
            // Clear all formats
            if (toolbar) {
              e.preventDefault();
              clearStickyFormats(editorId, toolbar);
            }
            return;
          }
        } else {
          // Simple format shortcuts
          switch(e.key.toLowerCase()) {
            case 'b':
              format = 'bold';
              break;
            case 'i':
              format = 'italic';
              break;
            case 'u':
              format = 'underline';
              break;
          }
        }
        
        if (format && toolbar) {
          e.preventDefault();
          const btn = toolbar.querySelector(`[data-format="${format}"]`);
          if (btn) {
            const editor = document.getElementById(editorId);
            if (editor) {
              applyFormatWithToggle(editor, editorId, format, btn, toolbar);
            }
          }
        }
      }
    });
  }
  
  // Get formatted content from editor (for saving)
  function getEditorContent(editorId) {
    const editor = document.getElementById(editorId);
    if (!editor) return '';
    
    // Convert HTML back to the text format expected by the backend
    // For checklist items, convert back to "- [ ] " or "- [x] " format with HTML preserved
    const clone = editor.cloneNode(true);
    
    // Process all child nodes
    const lines = [];
    Array.from(clone.childNodes).forEach(node => {
      if (node.tagName === 'LABEL') {
        const checkbox = node.querySelector('input[type="checkbox"]');
        const span = node.querySelector('span');
        if (checkbox && span) {
          const checked = checkbox.checked ? 'x' : ' ';
          // Preserve HTML in span
          const html = span.innerHTML.replace(/\u200B/g, ''); // Remove zero-width spaces
          lines.push(`- [${checked}] ${html}`);
        }
      } else if (node.tagName === 'DIV') {
        // Regular div content
        const html = node.innerHTML;
        if (html === '<br>') {
          lines.push(''); // Empty line
        } else {
          lines.push(html);
        }
      } else if (node.nodeType === Node.TEXT_NODE) {
        const text = node.textContent.trim();
        if (text) {
          lines.push(text);
        }
      }
    });
    
    return lines.join('\n').trim();
  }
  
  // Set editor content (when loading)
  function setEditorContent(editorId, content) {
    const editor = document.getElementById(editorId);
    if (!editor) return;
    
    // Parse content and convert "- [ ] " and "- [x] " to checkboxes
    const lines = String(content || '').split(/\n/);
    const fragments = [];
    
    lines.forEach((line, idx) => {
      const checkMatch = line.match(/^-\s*\[([ xX])\]\s*(.*)$/);
      if (checkMatch) {
        const checked = checkMatch[1].toLowerCase() === 'x';
        const text = checkMatch[2] || '';
        
        const label = document.createElement('label');
        label.style.display = 'flex';
        label.style.alignItems = 'start';
        label.style.gap = '0.5rem';
        label.style.padding = '0.125rem 0';
        label.style.userSelect = 'none';
        
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = checked;
        checkbox.className = 'desc-checkbox';
        checkbox.style.marginTop = '0.125rem';
        checkbox.style.flexShrink = '0';
        checkbox.style.cursor = 'pointer';
        
        const span = document.createElement('span');
        span.contentEditable = 'true';
        span.innerHTML = text || '\u200B'; // Allow HTML formatting, use zero-width space if empty
        span.style.cursor = 'text';
        span.style.userSelect = 'text';
        
        // Prevent label click from affecting checkbox when clicking on text
        label.addEventListener('mousedown', (e) => {
          if (e.target === checkbox) {
            return;
          }
          e.preventDefault();
          
          // If clicking on text span, focus it to allow text editing
          if (e.target === span || span.contains(e.target)) {
            span.focus();
            // Try to place cursor at click position
            const range = document.caretRangeFromPoint(e.clientX, e.clientY);
            if (range) {
              const selection = window.getSelection();
              selection.removeAllRanges();
              selection.addRange(range);
            }
          }
        });
        
        // Make checkbox independently clickable
        checkbox.addEventListener('mousedown', (e) => {
          e.stopPropagation();
        });
        
        label.appendChild(checkbox);
        label.appendChild(span);
        fragments.push(label);
      } else {
        const div = document.createElement('div');
        div.innerHTML = line || '<br>'; // Preserve empty lines
        fragments.push(div);
      }
    });
    
    editor.innerHTML = '';
    fragments.forEach(frag => editor.appendChild(frag));
  }
  
  // Old formatting toolbar code removed - no longer needed with Checklist + Notes system
})();
</script>

<script src="/assets/js/theme.js"></script>
<script type="module" src="/tasks-checklist.js"></script>
<script src="/assets/js/sound.js" defer></script>
<script src="/assets/js/toast.js" defer></script>
<script src="/assets/js/notifications.js" defer></script>
</body>
</html>
